<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Visual Computing 2022-2</title><link>https://anfbalceroce.github.io/VisualComputing/docs/shaders/</link><description>Recent content on Visual Computing 2022-2</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://anfbalceroce.github.io/VisualComputing/docs/shaders/index.xml" rel="self" type="application/rss+xml"/><item><title>Coloring</title><link>https://anfbalceroce.github.io/VisualComputing/docs/shaders/coloring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anfbalceroce.github.io/VisualComputing/docs/shaders/coloring/</guid><description>Exercise # Figure it out the js code of the above sketches. Implement other blending modes. Blending Modes # Esta aplicación aplica diferentes modos de blend a una imagen con un color. La imagen y el color son seleccionados por el usuario.
Primero se renderiza la imagen cargada, y se envía como textura al blend shader. Al blend shader se le envía el color seleccionado por el usuario como un arreglo de JavaScript de cuatro posiciones.</description></item><item><title>Texturing</title><link>https://anfbalceroce.github.io/VisualComputing/docs/shaders/texturing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anfbalceroce.github.io/VisualComputing/docs/shaders/texturing/</guid><description>Exercise # Implement other coloring brightness tools such as HSV value V, HSL lightness L or Component average. Implement texture tinting by mixing color and texel interpolated data. Brightness &amp;amp; Tinting # El ejercicio se compone de dos partes: La primera consiste en la visualización de la iluminación de la imagen y la segunda es la aplicación de tinting sobre la imagen utilizando diferentes blending modes.
La iluminación se implementó con un brightness shader usando las siguientes cuatro métricas: luma, value (HSV), lightness (HSL) e intensidad (HSI).</description></item><item><title>Image Processing</title><link>https://anfbalceroce.github.io/VisualComputing/docs/shaders/ImageProcessing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anfbalceroce.github.io/VisualComputing/docs/shaders/ImageProcessing/</guid><description>Exercise # Implement an image / video processing app supporting different masks, including other kernel sizes different than 3x3, and:
A region-of-interest base tool to selectively apply a given mask.Hint: circular regions around the mouse pointer are handy and quite simple to implement by means of glsl distance. A magnifier tool. Requires a bit of research. For instance, look for it in shadertoy. Integrate luma and other coloring brightness tools.</description></item><item><title>Procedural Texturing</title><link>https://anfbalceroce.github.io/VisualComputing/docs/shaders/ProceduralTexturing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anfbalceroce.github.io/VisualComputing/docs/shaders/ProceduralTexturing/</guid><description>Exercise # Adapt other patterns from the book of shaders (refer also to the shadertoy collection) and map them as textures onto other 3D shapes.
Procedural Texturing # En este ejercicio, se implementaron dos patrones. Uno tomado de The Book of Shaders: Random llamado Mosaic y otro tomado de generative art deco 4 (Shadertoy) y que aplica el concepto de Chromatic aberration.
Por defecto se mostrará este segundo shader sobre un conjunto de conos generados aleatoriamente y que se mueven cíclicamente por el espacio (mod 400) mientras rotan.</description></item><item><title>Non-Euclidean geometry</title><link>https://anfbalceroce.github.io/VisualComputing/docs/shaders/non-euclidean_geometry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anfbalceroce.github.io/VisualComputing/docs/shaders/non-euclidean_geometry/</guid><description>Non-Euclidean geometry # Todo tipo de geometría no euclidiana puede ser implementado creando un vinculo entre diferentes partes del espacio 3D en el que comparten el mismo punto de vista.
¿Cómo se hace? # Todas las figuras se renderizan primero en sus propios objetos buffer p5.Graphics fuera de la pantalla utilizando el mismo punto de vista. Los n búferes obtenidos se mapean en las n caras del lienzo principal utilizando un shader personalizado, de nuevo desde el mismo punto de vista.</description></item><item><title>Spatial Coherence</title><link>https://anfbalceroce.github.io/VisualComputing/docs/shaders/SpatialCoherence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anfbalceroce.github.io/VisualComputing/docs/shaders/SpatialCoherence/</guid><description>Exercise # Implement your own source dataset and a mechanism to select different images from it. Implement a pixelator in software that doesn’t use spatial coherence and compare the results with those obtained here. Spatial Coherence # En este ejericio se hace una implementación del pixelado de imágenes usando coherencia espacial. El shader pixelator recibe la imagen y la resolución a utilizar. Una resolución de 30 significa que la imagen pixelada tendrá 30 pixeles de baja resolución (grandes) en cada lado.</description></item><item><title>Photomosaic</title><link>https://anfbalceroce.github.io/VisualComputing/docs/shaders/photomosaic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anfbalceroce.github.io/VisualComputing/docs/shaders/photomosaic/</guid><description>Exercise # Implement a mosaic (or/and ascii art) visual application.
Images Photomosaic # En esta aplicación, se usa el mismo mecanismo de pixelación visto en Spatial Coherence con la diferencia de que cada pixel de baja resolución es mapeado a una imagen. El shader recibe una imagen (buffer) que contiene todas las imágenes del dataset que compondrán el mosaico. Estas imágenes están ordenadas siguiendo alguna métrica, que en nuestro caso es el luma.</description></item><item><title>Lighting</title><link>https://anfbalceroce.github.io/VisualComputing/docs/shaders/lighting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anfbalceroce.github.io/VisualComputing/docs/shaders/lighting/</guid><description>Lighting # La iluminación en gráficos por computadora se refiere a la colocación de luces en una escena para lograr algún efecto deseado. Los paquetes de síntesis de imágenes y animación contienen diferentes tipos de luces que se pueden colocar en diferentes lugares y modificar cambiando los parámetros. Con demasiada frecuencia, las personas que crean imágenes o animaciones ignoran o ponen poco énfasis en la iluminación. [2]
En gráficos por computadora, el efecto general de una fuente de luz sobre un objeto está determinado por la combinación de las interacciones del objeto con él, generalmente descritas por al menos tres componentes principales.</description></item></channel></rss>
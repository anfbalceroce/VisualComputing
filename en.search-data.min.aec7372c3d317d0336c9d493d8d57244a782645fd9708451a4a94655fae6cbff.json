[{"id":0,"href":"/VisualComputing/docs/shaders/coloring/","title":"Coloring","section":"Shaders","content":" Exercise # Figure it out the js code of the above sketches. Implement other blending modes. Blending Modes # Esta aplicación aplica diferentes modos de blend a una imagen con un color. La imagen y el color son seleccionados por el usuario.\nPrimero se renderiza la imagen cargada, y se envía como textura al blend shader. Al blend shader se le envía el color seleccionado por el usuario como un arreglo de JavaScript de cuatro posiciones. Cada entrada se divide en 255 para representar un color RGBA normalizado [0..1].\nEl blend shader toma el color de cada texel que recibe en la textura (imagen cargada y recibida) y hace el cálculo del blend con el color (vec4) recibido, utilizando la fórmula según corresponda.\nEl resultado de la operación de blend es un color que para el pixel de la textura de salida, la cual se renderiza sobre el cuadrado de la parte inferior.\nEsa textura renderizada en la parte inferior es la misma imagen cargada al inicio pero sus colores son el resultado de la operación de blend correspondiente texel a texel con el color seleccionado por el usuario.\nLos blending modes implementados son: multiply, add (linear dodge), screen, overlay, darkest, lightest, color burn, linear burn, difference, divide, exclusion, color dodge, hard light, vivid light, linear light, pin light t cuatro versiones de soft light: photoshop, pegtop, ilussions.hu y w3c.\nLas fórmulas fueron tomadas de Blend Modes (Wikipedia) y Formulas for Photoshop blending modes (RBA\u0026rsquo;s Astrophotography)\nOtras referencias utilizadas: Why my texture coordinates are inverted each time I call my GLSL shader in P5.js (Stack Overflow)\nControles # Botón Choose File: para cargar una imagen o video Checkbox Default Video: marcar para usar el video por defecto, desmarcar para usar la imagen por defecto Slider: controla el brillo Select: selecciona el blending mode que desea utilizar Color Picker: selecciona el color que se usará en la operación de blend seleccionada para cada texel de la imagen (o video) cargada Código # Sketch Code let blendShader; let colorB; // picked by user let B; // vec4 vector sent to shader let tex; // shader output texture let cpickerB; let bslider; // brightness slider let bmselect; // blending mode select let brightness; let mode; let img; // shader input texture let input; let video_on; function preload() { blendShader = readShader(\u0026#39;/VisualComputing/docs/shaders/fragments/blend.frag\u0026#39;, { matrices: Tree.NONE, varyings: Tree.texcoords2 }); } function setup() { createCanvas(900, 850, WEBGL); colorB = color(10, 255, 170); tex = createGraphics(800, 800, WEBGL); cpickerB = createColorPicker(colorB); cpickerB.position(490, 200); bslider = createSlider(0, 1, 1, 0.05); bslider.position(490, 120); bslider.style(\u0026#39;width\u0026#39;, \u0026#39;80px\u0026#39;); bmselect = createSelect(); bmselect.position(490, 160); bmselect.option(\u0026#39;MULTIPLY\u0026#39;, 0); bmselect.option(\u0026#39;ADD (LINEAR DODGE)\u0026#39;, 1); bmselect.option(\u0026#39;SCREEN\u0026#39;, 2); bmselect.option(\u0026#39;OVERLAY\u0026#39;, 3); bmselect.option(\u0026#39;DARKEST\u0026#39;, 4); bmselect.option(\u0026#39;LIGHTEST\u0026#39;, 5); bmselect.option(\u0026#39;COLOR BURN\u0026#39;, 6); bmselect.option(\u0026#39;LINEAR BURN\u0026#39;, 7); bmselect.option(\u0026#39;DIFFERENCE\u0026#39;, 8); bmselect.option(\u0026#39;DIVIDE\u0026#39;, 9); bmselect.option(\u0026#39;EXCLUSION\u0026#39;, 10); bmselect.option(\u0026#39;COLOR DODGE\u0026#39;, 11); bmselect.option(\u0026#39;HARD LIGHT\u0026#39;, 12); bmselect.option(\u0026#39;VIVID LIGHT\u0026#39;, 13); bmselect.option(\u0026#39;LINEAR LIGHT\u0026#39;, 14); bmselect.option(\u0026#39;PIN LIGHT\u0026#39;, 15); bmselect.option(\u0026#39;SOFT LIGHT 1\u0026#39;, 16); // photoshop bmselect.option(\u0026#39;SOFT LIGHT 2\u0026#39;, 17); // pegtop bmselect.option(\u0026#39;SOFT LIGHT 3\u0026#39;, 18); // ilussions.hu bmselect.option(\u0026#39;SOFT LIGHT 4\u0026#39;, 19); // w3C bmselect.selected(\u0026#39;MULTIPLY\u0026#39;); img = loadImage(\u0026#39;/VisualComputing/docs/shaders/resources/image.jpg\u0026#39;); input = createFileInput(handleFile); video_on = createCheckbox(\u0026#39;default video\u0026#39;, false); video_on.changed(() =\u0026gt; { if (video_on.checked()) { img = createVideo([\u0026#39;/VisualComputing/docs/shaders/resources/video0.mp4\u0026#39;]); img.hide(); } else { img = loadImage(\u0026#39;/VisualComputing/docs/shaders/resources/image.jpg\u0026#39;); img.hide(); img.pause(); } blendShader.setUniform(\u0026#39;texture\u0026#39;, img); }) } function draw() { colorB = cpickerB.color() background(0); image(img, -450, -400, 400, 400); fill(colorB) square(30, -170, 150); // vec4 vector sent to shader B = [colorB._getRed() / 255, colorB._getGreen() / 255, colorB._getBlue() / 255, alpha(colorB) / 255] // normalized brightness = bslider.value(); mode = bmselect.value(); tex.shader(blendShader) blendShader.setUniform(\u0026#39;texture\u0026#39;, img); // each texel will be color A blendShader.setUniform(\u0026#39;colorB\u0026#39;, B); blendShader.setUniform(\u0026#39;brightness\u0026#39;, brightness); blendShader.setUniform(\u0026#39;mode\u0026#39;, mode); tex.square(); texture(tex); square(-600, 10, 800); } function handleFile(file) { if (file.type === \u0026#39;image\u0026#39;) { img = createImg(file.data, \u0026#39;\u0026#39;); img.hide(); } else if (file.type === \u0026#39;video\u0026#39;) { img = createVideo([file.data]); img.hide(); img.loop(); } } Blend Shader precision mediump float; uniform vec4 colorB; uniform float brightness; // [0, 1] uniform int mode; uniform sampler2D texture; varying vec2 texcoords2; void main() { // https://stackoverflow.com/questions/67576655/why-my-texture-coordinates-are-inverted-each-time-i-call-my-glsl-shader-in-p5js vec4 colorA = texture2D(texture, vec2(texcoords2.x, 1.0 - texcoords2.y)); // each texel is color A if (mode == 0) { // multiply gl_FragColor = colorA * colorB * brightness; } else if (mode == 1) { // add (linear dodge) gl_FragColor = (colorA + colorB) * brightness; } else if (mode == 2) { // screen gl_FragColor = (1. - (1. - colorA) * (1. - colorB)) * brightness; } else if (mode == 3) { // overlay float R = (colorA[0] \u0026lt; 0.5) ? 2. * colorA[0] * colorB[0] : (1. - (1. - colorA[0]) * (1. - colorB[0])); float G = (colorA[1] \u0026lt; 0.5) ? 2. * colorA[1] * colorB[1] : (1. - (1. - colorA[1]) * (1. - colorB[1])); float B = (colorA[2] \u0026lt; 0.5) ? 2. * colorA[2] * colorB[2] : (1. - (1. - colorA[2]) * (1. - colorB[2])); float A = (colorA[3] \u0026lt; 0.5) ? 2. * colorA[3] * colorB[3] : (1. - (1. - colorA[3]) * (1. - colorB[3])); gl_FragColor = vec4(R, G, B, A) * brightness; } else if (mode == 4) { // darkest gl_FragColor = vec4(min(colorA[0], colorB[0]), min(colorA[1], colorB[1]), min(colorA[2], colorB[2]), min(colorA[3], colorB[3])) * brightness; } else if (mode == 5) { // lightest gl_FragColor = vec4(max(colorA[0], colorB[0]), max(colorA[1], colorB[1]), max(colorA[2], colorB[2]), max(colorA[3], colorB[3])) * brightness; } else if (mode == 6) { // color burn gl_FragColor = 1. - ((1. - colorA) / colorB) * brightness; } else if (mode == 7) { // linear burn gl_FragColor = (colorA + colorB - 1.) * brightness; } else if (mode == 8) { // difference gl_FragColor = (abs(colorA - colorB)) * brightness; } else if (mode == 9) { // divide gl_FragColor = (colorA / colorB) * brightness; } else if (mode == 10) { // exclusion gl_FragColor = (0.5 - 2. * (colorA - 0.5) * (colorB - 0.5)) * brightness; } else if (mode == 11) { // color dodge gl_FragColor = (colorA / (1. - colorB)) * brightness; } else if (mode == 12) { // hard light float R = (colorB[0] \u0026gt; 0.5) ? (1. - (1. - colorA[0]) * (1. - 2. * (colorB[0] - 0.5))) : colorA[0] * 2. * colorB[0]; float G = (colorB[1] \u0026gt; 0.5) ? (1. - (1. - colorA[1]) * (1. - 2. * (colorB[1] - 0.5))) : colorA[1] * 2. * colorB[1]; float B = (colorB[2] \u0026gt; 0.5) ? (1. - (1. - colorA[2]) * (1. - 2. * (colorB[2] - 0.5))) : colorA[2] * 2. * colorB[2]; float A = (colorB[3] \u0026gt; 0.5) ? (1. - (1. - colorA[3]) * (1. - 2. * (colorB[3] - 0.5))) : colorA[3] * 2. * colorB[3]; gl_FragColor = vec4(R, G, B, A) * brightness; } else if (mode == 13) { // vivid light float R = (colorB[0] \u0026gt; 0.5) ? colorA[0] / (1. - 2. * (colorB[0] - 0.5)) : (1. - (1. - colorA[0]) / (2. * colorB[0])); float G = (colorB[1] \u0026gt; 0.5) ? colorA[1] / (1. - 2. * (colorB[1] - 0.5)) : (1. - (1. - colorA[1]) / (2. * colorB[1])); float B = (colorB[2] \u0026gt; 0.5) ? colorA[2] / (1. - 2. * (colorB[2] - 0.5)) : (1. - (1. - colorA[2]) / (2. * colorB[2])); float A = (colorB[3] \u0026gt; 0.5) ? colorA[3] / (1. - 2. * (colorB[3] - 0.5)) : (1. - (1. - colorA[3]) / (2. * colorB[3])); gl_FragColor = vec4(R, G, B, A) * brightness; } else if (mode == 14) { // vivid light float R = (colorB[0] \u0026gt; 0.5) ? colorA[0] + 2. * (colorB[0] - 0.5) : (colorA[0] + 2. * colorB[0] - 1.); float G = (colorB[1] \u0026gt; 0.5) ? colorA[1] + 2. * (colorB[1] - 0.5) : (colorA[1] + 2. * colorB[1] - 1.); float B = (colorB[2] \u0026gt; 0.5) ? colorA[2] + 2. * (colorB[2] - 0.5) : (colorA[2] + 2. * colorB[2] - 1.); float A = (colorB[3] \u0026gt; 0.5) ? colorA[3] + 2. * (colorB[3] - 0.5) : (colorA[3] + 2. * colorB[3] - 1.); gl_FragColor = vec4(R, G, B, A) * brightness; } else if (mode == 15) { // pin light float R = (colorB[0] \u0026gt; 0.5) ? max(colorA[0], 2. * (colorB[0] - 0.5)) : min(colorA[0], 2. * colorB[0]); float G = (colorB[1] \u0026gt; 0.5) ? max(colorA[1], 2. * (colorB[1] - 0.5)) : min(colorA[1], 2. * colorB[1]); float B = (colorB[2] \u0026gt; 0.5) ? max(colorA[2], 2. * (colorB[2] - 0.5)) : min(colorA[2], 2. * colorB[2]); float A = (colorB[3] \u0026gt; 0.5) ? max(colorA[3], 2. * (colorB[3] - 0.5)) : min(colorA[3], 2. * colorB[3]); gl_FragColor = vec4(R, G, B, A) * brightness; } else if (mode == 16) { // soft light photoshop float R = (colorB[0] \u0026lt; 0.5) ? 2. * colorA[0] * colorB[0] + colorA[0] * colorA[0] * (1. - 2. * colorB[0]) : 2. * colorA[0] * (1. - colorB[0]) + sqrt(colorA[0]) * (2. * colorB[0] - 1.); float G = (colorB[1] \u0026lt; 0.5) ? 2. * colorA[1] * colorB[1] + colorA[1] * colorA[1] * (1. - 2. * colorB[1]) : 2. * colorA[1] * (1. - colorB[1]) + sqrt(colorA[1]) * (2. * colorB[1] - 1.); float B = (colorB[2] \u0026lt; 0.5) ? 2. * colorA[2] * colorB[2] + colorA[2] * colorA[2] * (1. - 2. * colorB[2]) : 2. * colorA[2] * (1. - colorB[2]) + sqrt(colorA[2]) * (2. * colorB[2] - 1.); float A = (colorB[3] \u0026lt; 0.5) ? 2. * colorA[3] * colorB[3] + colorA[3] * colorA[3] * (1. - 2. * colorB[3]) : 2. * colorA[3] * (1. - colorB[3]) + sqrt(colorA[3]) * (2. * colorB[3] - 1.); gl_FragColor = vec4(R, G, B, A) * brightness; } else if (mode == 17) { // soft light pegtop gl_FragColor = ((1. - (2. * colorB)) * (colorA * colorA) + (2. * colorB * colorA)) * brightness; } else if (mode == 18) { // soft light illusions.hu float R = pow(colorA[0], pow(2., 2. * (0.5 - colorB[0]))); float G = pow(colorA[1], pow(2., 2. * (0.5 - colorB[1]))); float B = pow(colorA[2], pow(2., 2. * (0.5 - colorB[2]))); float A = pow(colorA[3], pow(2., 2. * (0.5 - colorB[3]))); gl_FragColor = vec4(R, G, B, A) * brightness; } else if (mode == 19) { // soft-light w3c float gRa = (colorA[0] \u0026lt;= 0.25) ? ((16. * colorA[0] - 12.) * colorA[0] + 4.) * colorA[0] : sqrt(colorA[0]); float gGa = (colorA[1] \u0026lt;= 0.25) ? ((16. * colorA[1] - 12.) * colorA[1] + 4.) * colorA[1] : sqrt(colorA[1]); float gBa = (colorA[2] \u0026lt;= 0.25) ? ((16. * colorA[2] - 12.) * colorA[2] + 4.) * colorA[2] : sqrt(colorA[2]); float gAa = (colorA[3] \u0026lt;= 0.25) ? ((16. * colorA[3] - 12.) * colorA[3] + 4.) * colorA[3] : sqrt(colorA[3]); float R = (colorB[0] \u0026lt;= 0.5) ? colorA[0] - (1. - 2. * colorB[0]) * colorA[0] * (1. - colorA[0]) : colorA[0] + (2. * colorB[0] - 1.) * (gRa - colorA[0]); float G = (colorB[1] \u0026lt;= 0.5) ? colorA[1] - (1. - 2. * colorB[1]) * colorA[1] * (1. - colorA[1]) : colorA[1] + (2. * colorB[1] - 1.) * (gGa - colorA[1]); float B = (colorB[2] \u0026lt;= 0.5) ? colorA[2] - (1. - 2. * colorB[2]) * colorA[2] * (1. - colorA[2]) : colorA[2] + (2. * colorB[2] - 1.) * (gBa - colorA[2]); float A = (colorB[3] \u0026lt;= 0.5) ? colorA[3] - (1. - 2. * colorB[3]) * colorA[3] * (1. - colorA[3]) : colorA[3] + (2. * colorB[3] - 1.) * (gAa - colorA[3]); gl_FragColor = vec4(R, G, B, A) * brightness; } // http://www.deepskycolors.com/archivo/2010/04/21/formulas-for-Photoshop-blending-modes.html } "},{"id":1,"href":"/VisualComputing/docs/taller-1/ilusiones/","title":"Ilusiones","section":"Taller 1","content":" Ilusiones # Introducción # Aquí se presentan cada una de las siguiente ilusiones con sus respectivas explicaciones sobre cómo funcionan, tratando de explicar porque se dan dichos fenómenos al analizar los diferentes componente de cada ilusiòn.\nSteping Illusion # En esta ilusion se observan dos rectangulos de color amarillo y azul que se desplazan a lo largo de un patron de barras claras y oscuras. Cuando las condiciones de color y tamaño son adecuadas los rectangulos parecen moverse de manera intermitente, como si fueran pies caminando.\nCuando el pie amarillo tiene un brillo similar a las barras claras, y el pie azul un brillo similar a las barras oscuras (caso extremo cuando son del mismo color y suficiente contraste entre los claros y los oscuros) solo hay evidencia clara de movimiento cuando los extremos del rectangulo claro pasan sobre una barra oscura o los del rectangulo oscuro pasan sobre una barra clara, efectivamente la mitad del espacio. En la otra mitad no (claro en claro o oscuro en oscuro) no es evidente el movimiento por lo que el cerebro asume que no hay movimiento (por defecto si algo no está en movimiento, entonces está en reposo).\nEste fenómeno también explica otra posible ilusión, que no se vean los rectángulos caminando si no oscilando, como un gusano. Esto se logra cuando la razón entre el largo del rectángulo y el ancho de las barras es un número impar (un número par causa la ilusión de caminar).\nAutor: Tomado de https://michaelbach.de/ot/mot-feetLin/index.htmlm, Autor: Michael Bach\nCòdigo let barWidth; let x = 0; let feetWidth; let feetHeight; let feetDistance; let speed; let direction = 1; let barWidthSlider; let feetWidthSlider; let feetHeightSlider; let feetDistanceSlider; let speedSlider; const labels = [\u0026#34;Ancho\\nBarras\u0026#34;,\u0026#34;Longitud\\nPies\u0026#34;,\u0026#34;Ancho\\nPies\u0026#34;,\u0026#34;Distancia\\nPies\u0026#34;,\u0026#34;Velocidad\u0026#34;]; function setup() { createCanvas(450, 380); frameRate(60); colorMode(HSB); barWidthSlider = createSlider(5, 50, 25); barWidthSlider.position(5, 310); barWidthSlider.style(\u0026#39;width\u0026#39;, \u0026#39;80px\u0026#39;); feetWidthSlider = createSlider(5, 150, 100); feetWidthSlider.position(90, 310); feetWidthSlider.style(\u0026#39;width\u0026#39;, \u0026#39;80px\u0026#39;); feetHeightSlider = createSlider(5, 0.5*(height-80), 25); feetHeightSlider.position(175, 310); feetHeightSlider.style(\u0026#39;width\u0026#39;, \u0026#39;80px\u0026#39;); feetDistanceSlider = createSlider(0, (height-80), 40); feetDistanceSlider.position(260, 310); feetDistanceSlider.style(\u0026#39;width\u0026#39;, \u0026#39;80px\u0026#39;); speedSlider = createSlider(0, 300, 100); speedSlider.position(345, 310); speedSlider.style(\u0026#39;width\u0026#39;, \u0026#39;80px\u0026#39;); } function draw() { speed = direction * speedSlider.value()/100; barWidth = barWidthSlider.value(); if (x + feetWidthSlider.value() \u0026lt;= width){ feetWidth = feetWidthSlider.value(); } feetHeight = feetHeightSlider.value(); if (feetDistanceSlider.value() \u0026lt;= (height-80)-2*feetHeight){ feetDistance = feetDistanceSlider.value(); }else{ feetDistance = (height-80)-2*feetHeight; } background(0,0,98); stroke(0,0,0); fill(0,0,0); for (let i = 0; i \u0026lt; width; i = i + 2 * barWidth) { rect(i,0,barWidth,(height-80)); } stroke(60,100,100); fill(60,100,100); rect(x,(0.5*(height-80))-feetHeight-0.5*feetDistance,feetWidth,feetHeight); stroke(240,100,40); fill(240,100,40); rect(x,(0.5*(height-80))+0.5*feetDistance,feetWidth,feetHeight); x = x + speed; if (x \u0026gt;= width-feetWidth) { direction = -1; } if (x \u0026lt;= 0) { direction = 1; } stroke(0,0,100); fill(0,0,100); rect(0,300,width,80); textSize(16); textAlign(CENTER); stroke(0,0,0); fill(0,0,0); text(labels[0], 45, 347); text(labels[1], 130, 347); text(labels[2], 215, 347); text(labels[3], 300, 347); text(labels[4], 385, 347); } Complementary Colors # Existe algo llamado \u0026ldquo;imagen remanente retiniana negativa\u0026rdquo;. Se vuelve visible cuando un tono determinado permanece en la misma posición de la retina durante varios segundos (por lo general, moveríamos los ojos 3 veces por segundo, por lo que esto no es una desventaja en la visualización normal). La imagen remanente se acumula a medida que esa ubicación retiniana se adapta a este tono especial, y al mirar un fondo neutro se ve el color complementario. Investigaciones recientes han localizado de manera convincente las células ganglionares de la retina como sustrato neural para la imagen residual (Zaidi et al. 2012).\nEsto es algo bueno, normalmente, porque ayuda a la \u0026ldquo;constancia del color\u0026rdquo;, es decir, vemos colores algo independientes de la iluminación ambiental (compare el sol glaciar azulado del mediodía con un tinte rojizo en la sala de estar junto a la chimenea).\nEntonces la imagen residual está \u0026ldquo;grabada\u0026rdquo;, lo que significa que la ubicación de la retina está adaptada. Ahora el parche magenta cambia repentinamente a gris. Por la adaptación, ahora se ve el color complementario, que sería el verde para el magenta, o el gris claro para un gris oscuro.\nLa imagen residual de la retina generalmente se desvanece rápidamente (en unos pocos segundos en condiciones normales). Pero aquí este desvanecimiento no reduce la percepción de la imagen remanente, porque se descubre una nueva justo después en la siguiente ubicación.\nAdemás, un efecto Gestalt, aquí entra en juego el \u0026ldquo;fenómeno phi\u0026rdquo;: la imagen residual de las sucesivas ubicaciones retinianas se integra y se percibe como un solo objeto en movimiento, a saber, el disco verde.\nEn resumen, los siguientes factores hacen que esta ilusión sea bastante convincente:\nEs bastante fácil fijarse constantemente en el centro La mayoría de las veces, las ubicaciones de la retina se readaptan y la imagen remanente se descubre solo brevemente Un efecto Gestalt conduce a la percepción de un disco verde volador. Tomado de https://michaelbach.de/ot/col-lilacChaser/index.html, Autor: Michael Bach\nCòdigo let colors = []; let maincolor let flag = false; let select function setup() { createCanvas(500, 500); angleMode(DEGREES); select = createSelect(); select.option(\u0026#39;magenta\u0026#39;); select.option(\u0026#39;yellow\u0026#39;); select.option(\u0026#39;cyan\u0026#39;); select.option(\u0026#39;red\u0026#39;); select.option(\u0026#39;blue\u0026#39;); select.option(\u0026#39;green\u0026#39;); select.option(color(255, 216, 255)); /* magenta with 15% saturation */ select.option(color(255, 255, 216)); /* yellow with 15% saturation */ select.option(color(216, 255, 255)); /* cyan with 15% saturation */ select.changed(selectEvent); maincolor = select.value() colors = [color(maincolor), color(maincolor), color(maincolor), color(maincolor), color(maincolor), color(maincolor), color(maincolor), color(maincolor), color(maincolor), color(maincolor), color(maincolor), color(maincolor)] } function draw() { background(240); strokeWeight(1); noStroke(); fill(240); circle(250, 250, 400); let p0 = createVector(450, 250); let p30 = createVector(cos(30)*200 + 200 + 50, (1-sin(30))*200 + 50); let p60 = createVector(cos(60)*200 + 200 + 50, (1-sin(60))*200 + 50); let p90 = createVector(250, 50); let p120 = createVector((1-(-cos(120)))*200 + 50, (1-sin(120))*200 + 50); let p150 = createVector((1-(-cos(150)))*200 + 50, (1-sin(150))*200 + 50); let p180 = createVector(50, 250); let p210 = createVector((1-(-cos(210)))*200 + 50, -sin(210)*200 + 200 + 50); let p240 = createVector((1-(-cos(240)))*200 + 50, -sin(240)*200 + 200 + 50); let p270 = createVector(250, 450); let p300 = createVector(cos(300)*200 + 200 + 50, -sin(300)*200 + 200 + 50); let p330 = createVector(cos(330)*200 + 200 + 50, -sin(330)*200 + 200 + 50) point(p0); point(p30); point(p60); point(p90); point(p120); point(p150); point(p180); point(p210); point(p240); point(p270); point(p300); point(p330); noStroke(); fill(colors[0]); circle(p0.x, p0.y, 60); fill(colors[1]); circle(p30.x, p30.y, 60); fill(colors[2]); circle(p60.x, p60.y, 60); fill(colors[3]); circle(p90.x, p90.y, 60); fill(colors[4]); circle(p120.x, p120.y, 60); fill(colors[5]); circle(p150.x, p150.y, 60); fill(colors[6]); circle(p180.x, p180.y, 60); fill(colors[7]); circle(p210.x, p210.y, 60); fill(colors[8]); circle(p240.x, p240.y, 60); fill(colors[9]); circle(p270.x, p270.y, 60); fill(colors[10]); circle(p300.x, p300.y, 60); fill(colors[11]); circle(p330.x, p330.y, 60); strokeWeight(10); stroke(1) point(250, 250) if (flag == false) go(); flag = true; } async function go() { for (let i = 0; i \u0026lt; colors.length; i++) { await sleep(200); if (i == 0) colors[colors.length - 1] = color(maincolor); else colors[i-1] = color(maincolor); colors[i] = color(240); } flag = false; } function selectEvent() { maincolor = select.value() } function sleep(ms) { return new Promise(resolve =\u0026gt; setTimeout(resolve, ms)); } Spinning Ellipses # El efecto consiste en una ilusión de movimiento, dado que es una serie de elipses que gira respecto a otro a una razón de 0.003 grados se crea un \u0026ldquo;puente\u0026rdquo; entre elipses, que a su vez crea un arco con el borde exterior de los elipses conectados subsecuentemente, mirando el punto central se puede ver como se crean dos patrones de espiral, lo que a su vez al estar rotando da esta espiral \u0026ldquo;hipnótica\u0026rdquo;. Si se mira durante un tiempo y luego se mira un fondo blanco dejará una impresión en la visión como de un halo alrededor de donde se encontraba el punto central.\nTomado de: https://youtu.be/xlPWCrjQsTE, Autor: Computing Masterclass\nCòdigo let angle = 0; function setup() { createCanvas(500, 500); strokeWeight(4); } function draw() { background(50); noStroke() fill(255,255,255) ellipse(width/2, height/2,10,10) for(let i = 15; i\u0026lt;500; i+=15){ push() //Empieza un nuevo dibujo translate(width/2,height/2) rotate(i+angle *2) noFill() stroke(i, i+100, 200) ellipse(0,0,i+20,i) //reemplazado i por slider.value pop() angle += 0.0003 } } function changeColor(){ background(bgcolor) } Moving Dots # El efecto consiste en una ilusión de movimiento, debido a que cada círculo contiene dos arcos de colores similares en movimiento de traslación sobre el mismo círculo, el ojo, al fijar su visión central solo en un punto o zona de toda la imagen, provoca que la visión periférica al captar el resto de la imagen, se dé un efecto de movimiento sobre los círculos, como si estuvieran bailando y moviéndose en forma de onda, a pesar de que el círculo central se encuentre siempre sin moverse, esto debido al movimiento contrario entre ambos arcos y que esten colocados de tal modo que, en cierto punto de rotaciòn, el circulo central queda expuesto a la zona exterior, provocando que la otra zona, con ambos arcos uno encima de otro, se vea como un circulo sin un pedazo\nTomado de : https://youtu.be/BQbrx6V0jTs, Autor: Computing Masterclass\nCòdigo let angle = 0; function setup() { createCanvas(700, 700); } function draw() { background(50); for (let i = 50; i \u0026lt; width - 45; i += 50) { for (let j = 50; j \u0026lt; height - 45; j += 50) { push() fill(0, 168, 0); stroke(0, 0, 150); strokeWeight(3); ellipse(i, j, 25, 25); pop() push() translate(i, j); rotate(HALF_PI + i - angle * 3) stroke(0, 168, 168); strokeWeight(3); noFill(); arc(0, 0, 30, 30, 0, PI) pop() push() translate(i, j); rotate(QUARTER_PI * j + angle * 4) stroke(0, 255, 255); strokeWeight(3); noFill(); arc(0, 0, 25, 25, PI , 0) pop() angle += 0.0005 } } } Conclusiones # Las ilusiones ópticas son efectos que logran engañar nuestro cerebro provocando que veamos cosas que no necesariamente ocurren de dicho modo, en este caso se presentaron, a través de ilusiones generada con código en p5 sin truco\nLas ilusiones opticas presentadas en su mayoria basadas en movimiento provocaron que los ojos humanos viera fenomenos difernetes a como se ejecutaban en realidad, esto debido a interpretaciones de nuestro cerebro ante diferens circunstacias que cambiaban por difernetes cirucunstacias, en el primero provcada por el fondo, en el segundo por el cambio de color sucesivo de los circulos de color rosa, el tercero por el movimiento y la sobreposicion de algunos arcos sobre otros, y el ultimo por el movimiento translacional de los dos arcos exteriores a los circulos\nReferences # Steping Illusion, Autor: Muchael Bach, Tomado de https://michaelbach.de/ot/mot-feetLin/index.html Complementary Colors, Autor: Michael Bach, Tomado de https://michaelbach.de/ot/col-lilacChaser/index.html Spinning Ellipses, Autor: Computing Masterclass, Tomado de: https://youtu.be/xlPWCrjQsTE Moving Dots, Autor: Computing Masterclass, Tomado de : https://youtu.be/BQbrx6V0jTs "},{"id":2,"href":"/VisualComputing/docs/taller-2/camaras/","title":"Múltiples Cámaras","section":"Taller 2","content":" Múltiples Cámaras # Tecla Acción W,A,S,D Movimiento E Aumentar velocidad Q Disminuir velocidad Introducción - Descripción de la idea # Para este proyecto se tomo como referencia las cámaras de punto fijo de los juegos de Resident Evil clásicos en los que se jugaba con una cámara de punto fijo:\nTanto el punto de vista como el cambio en las transiciones\nSe hizo uso de transformaciones en el espacio y de cámaras con quaterniones, los cuaterniones son muy ́utiles en la representación gráfica por ordenador, debido, entre otras cosas, a la posibilidad que ofrecen de representar con ellos rotaciones en el espacio tridimensional a través de los ángulos de Euler evitando el Gimbal Lock-Bloqueo del cardán. (Deformación de la imagen por perdida de libertad).\nDesarrollo # En el sketch se modela un entorno (primer piso del edificio insignia) en 3D utilizando la primitiva box() de p5 y se importan modelos y texturas para el jugador y otros elementos decorativos. En este modelado se utilizan las funciones push() y pop() para transformar cada elemento si impactar a los demás.\nDentro de este modelo se definen cuartos o habitaciones a partir de límites en coordenadas x, y. A cada cuarto se le asigna una cámara, representada como valores de Centro, Distancia y Rotación. Estos valores son utilizados por la librería easycam para ubicar una cámara en una esfera identificada por el Centro, Distancia y Rotación.\nEl jugador puede moverse con las teclas W, A, S, D, y cambiar su velocidad con las teclas E y Q. A medida que el jugador cambia de cuarto se cambia los parámetros de la cámara. En esta versión el movimiento siempre es relativo a una vista aérea sin rotaciones (implementada como un minimapa), queda la posibilidad de modificar el movimiento para que sea relativo a la cámara actual.\nTambién se hace uso de las coordenadas de cada pared y del jugador para detectar colisiones e impedir que el jugador atraviese paredes.\nCódigo /** * * The p5.EasyCam library - Easy 3D CameraControl for p5.js and WEBGL. * * Copyright 2018-2020 by p5.EasyCam authors * * Source: https://github.com/freshfork/p5.EasyCam * * MIT License: https://opensource.org/licenses/MIT * * * explanatory notes: * * p5.EasyCam is a derivative of the original PeasyCam Library by Jonathan Feinberg * and combines new useful features with the great look and feel of its parent. * * */ // // SplitView setup // // Two cameras, each one owns its own rendertarget. // // class wall { constructor(tlX, tlY, r, g, b, sX, sY){ this.tlX = tlX; this.tlY = tlY; this.r = r; this.g = g; this.b = b; this.sX = sX; this.sY = sY; } } const walls = [] walls.push(new wall(0, -75, 128, 64, 0, 90, 10)); walls.push(new wall(90, -75, 255,255,255, 90, 10)); walls.push(new wall(-90, -75, 255,255,255, 90, 10)); walls.push(new wall(140, -50, 255,255,255, 10, 60)); walls.push(new wall(-140, -50, 255,255,255, 10, 60)); walls.push(new wall(-75, 140, 255,255,255, 120, 10)); walls.push(new wall(75, 140, 255,255,255, 120, 10)); walls.push(new wall(-140, 90, 255,255,255, 10, 110)); walls.push(new wall(140, 90, 255,255,255, 10, 110)); walls.push(new wall(40, 90, 255,255,255, 5, 90)); walls.push(new wall(-40, 90, 255,255,255, 5, 90)); walls.push(new wall(-170, 40, 255, 255, 255, 50, 10)); walls.push(new wall(-170, 95, 128, 64, 0, 50, 10)); walls.push(new wall(-140, 290, 255,255,255, 10, 290)); walls.push(new wall(-280, 290, 255,255,255, 10, 290)); walls.push(new wall(-210, 440, 255,255,255, 150, 10)); walls.push(new wall(-280, 90, 255,255,255, 10, 110)); walls.push(new wall(-250, 95, 128,64,0, 50, 10)); walls.push(new wall(-250, 40, 255,255,255, 50, 10)); walls.push(new wall(-360, 140, 255,255,255, 150, 10)); walls.push(new wall(-345, 40, 255,255,255, 120, 10)); walls.push(new wall(-440, 90, 255,255,255, 10, 110)); walls.push(new wall(-520, 140, 2055,255,255, 150, 10)); walls.push(new wall(-535, 40, 255,255,255, 120, 10)); walls.push(new wall(-600, 90, 255,255,255, 10, 110)); walls.push(new wall(-630, 40, 255,255,255, 50, 10)); walls.push(new wall(-630, 95, 128,64,0, 50, 10)); walls.push(new wall(-600, 290, 255,255,255, 10, 290)); walls.push(new wall(-740, 290, 255,255,255, 10, 290)); walls.push(new wall(-670, 440, 255,255,255, 150, 10)); walls.push(new wall(-740, 90, 255,255,255, 10, 110)); walls.push(new wall(-710, 95, 128,64,0, 50, 10)); walls.push(new wall(-710, 40, 255,255,255, 50, 10)); walls.push(new wall(-770, 40, 255,255,255, 50, 10)); walls.push(new wall(-780, 140, 255,255,255, 70, 10)); walls.push(new wall(-820, 57.5, 255,255,255, 10, 175)); walls.push(new wall(-780, -25, 255,255,255, 70, 10)); walls.push(new wall(-740, -60, 255,255,255, 10, 80)); walls.push(new wall(-670, -105, 255,255,255, 150, 10)); walls.push(new wall(-600, -60, 255,255,255, 10, 80)); walls.push(new wall(-370, -25, 255,255,255, 450, 10)); walls.push(new wall(170, 40, 255,255,255, 50, 10)); walls.push(new wall(170, 95, 128,64,0, 50, 10)); walls.push(new wall(140, 290, 255,255,255, 10, 290)); walls.push(new wall(280, 290, 255,255,255, 10, 290)); walls.push(new wall(210, 440, 255,255,255, 150, 10)); walls.push(new wall(280, 90, 255,255,255, 10, 110)); walls.push(new wall(250, 95, 128,64,0, 50, 10)); walls.push(new wall(250, 40, 255,255,255, 50, 10)); walls.push(new wall(360, 140, 255,255,255, 150, 10)); walls.push(new wall(345, 40, 255,255,255, 120, 10)); walls.push(new wall(440, 90, 255,255,255, 10, 110)); walls.push(new wall(520, 140, 255,255,255, 150, 10)); walls.push(new wall(535, 40, 255,255,255, 120, 10)); walls.push(new wall(600, 90, 255,255,255, 10, 110)); walls.push(new wall(630, 40, 255,255,255, 50, 10)); walls.push(new wall(630, 95, 128,64,0, 50, 10)); walls.push(new wall(600, 290, 255,255,255, 10, 290)); walls.push(new wall(740, 290, 255,255,255, 10, 290)); walls.push(new wall(670, 440, 255,255,255, 150, 10)); walls.push(new wall(740, 90, 255,255,255, 10, 110)); walls.push(new wall(710, 95, 128,64,0, 50, 10)); walls.push(new wall(710, 40, 255,255,255, 50, 10)); walls.push(new wall(770, 40, 255,255,255, 50, 10)); walls.push(new wall(780, 140, 255,255,255, 70, 10)); walls.push(new wall(820, 57.5, 255,255,255, 10, 175)); walls.push(new wall(780, -25, 255,255,255, 70, 10)); walls.push(new wall(740, -60, 255,255,255, 10, 80)); walls.push(new wall(670, -105, 255,255,255, 150, 10)); walls.push(new wall(600, -60, 255,255,255, 10, 80)); walls.push(new wall(370, -25, 255,255,255, 450, 10)); class camState { constructor(distance, center, rotation){ this.distance = distance; this.center = center; this.rotation = rotation; } } const cams = [] //0 //cams.push(new camState(900, [-200, 0, 0], [0, 0, 0, 1])); //1 cams.push(new camState(197, [0, 0, 0], [0.006, -0.001, -0.109, 1])); //2 cams.push(new camState(130, [0, 60, 0], [-0.915, -0.332, -0.074, 0.211])); //3 cams.push(new camState(130, [90, 60, 0], [-0.910, -0.335, 0.098, -0.220])); //4 cams.push(new camState(130, [-90, 60, 0], [-0.910, -0.335, 0.098, -0.220])); //5 cams.push(new camState(132, [-210, 0, 0], [-0.002, 0, -0.033, 1])); //6 cams.push(new camState(120, [-210, 60, 0], [0.689, 0.191, -0.113, 0.677])); //7 cams.push(new camState(180, [-210, 270, 0], [ -0.873, -0.459, 0.104, -0.118])); //8 cams.push(new camState(134, [-360, 0, 0], [ 0.668, 0.256, 0.180, -0.674])); //9 cams.push(new camState(117, [-360, 90, 0], [ 0.794, 0.33, -0.195, 0.468])); //10 cams.push(new camState(113, [-510, 0, 0], [ 0.671, 0.284, -0.245, 0.649])); //11 cams.push(new camState(113, [-510, 90, 0], [ -0.515, -0.189, -0.354, 0.756])); //12 cams.push(new camState(120, [-720, 0, 0], [ 0.563, 0.249, 0.241, -0.749])); //13 cams.push(new camState(134, [-660, -45, 0], [ 0, -0.003, 0.164, -0.986])); //14 cams.push(new camState(120, [-660, 60, 0], [0.689, 0.191, 0.191, -0.687])); //15 cams.push(new camState(190, [-660, 270, 0], [ 0.855, 0.478, 0.105, -0.169])); //16 cams.push(new camState(100, [-765, 90, 0], [ .920, 0.161, 0.046, 0.351])); //17 cams.push(new camState(132, [210, 0, 0], [-0.002, 0, -0.033, 1])); //18 cams.push(new camState(120, [210, 60, 0], [0.689, 0.191, -0.113, 0.677])); //19 cams.push(new camState(180, [210, 270, 0], [ 0.852, 0.485, 0.100, -0.163])); //20 cams.push(new camState(134, [360, 0, 0], [ -0.668, -0.256, 0.180, -0.674])); //21 cams.push(new camState(117, [360, 90, 0], [ 0.794, 0.33, -0.195, 0.468])); //22 cams.push(new camState(113, [510, 0, 0], [ 0.671, 0.284, 0.245, -0.649])); //23 cams.push(new camState(100, [510, 90, 0], [ 0.810, 0.351, 0.185, -0.429])); //24 cams.push(new camState(130, [720, 0, 0], [ -0.671, -0.284, 0.237, -0.642])); //25 cams.push(new camState(134, [660, -45, 0], [ 0, -0.003, 0.164, -0.986])); //26 cams.push(new camState(105, [660, 60, 0], [0.689, 0.191, 0.191, -0.687])); //27 cams.push(new camState(190, [660, 270, 0], [ 0.864, 0.482, 0.061, -0.127])); //28 cams.push(new camState(100, [765, 90, 0], [ 0.869, 0.291, -0.138, 0.374])); var currentCam = 1; var camX; var camY; var camZ; class room { constructor(X1, X2, Y1, Y2){ this.X1 = X1; this.X2 = X2; this.Y1 = Y1; this.Y2 = Y2; } } const rooms = [] rooms.push(new room(-140, 140, -75, 45)); rooms.push(new room(-40, 40, 45, 135)); rooms.push(new room(40, 130, 45, 135)); rooms.push(new room(-130, -40, 45, 135)); rooms.push(new room(-280, -140, -15, 30)); rooms.push(new room(-280, -140, 40, 95)); rooms.push(new room(-280, -140, 105, 430)); rooms.push(new room(-440, -290, -15, 30)); rooms.push(new room(-430, -290, 40, 130)); rooms.push(new room(-590, -440, -15, 30)); rooms.push(new room(-590, -450, 40, 130)); rooms.push(new room(-810, -600, -15, 30)); rooms.push(new room(-730, -610, -95, -25)); rooms.push(new room(-730, -610, 40, 95)); rooms.push(new room(-730, -610, 105, 430)); rooms.push(new room(-810, -750, 40, 130)); rooms.push(new room(140, 280, -15, 30)); rooms.push(new room(140, 280, 40, 95)); rooms.push(new room(140, 280, 105, 430)); rooms.push(new room(290, 440, -15, 30)); rooms.push(new room(290, 430, 40, 130)); rooms.push(new room(440, 590, -15, 30)); rooms.push(new room(450, 590, 40, 130)); rooms.push(new room(600, 810, -15, 30)); rooms.push(new room(610, 730, -95, -25)); rooms.push(new room(610, 730, 40, 95)); rooms.push(new room(610, 730, 105, 430)); rooms.push(new room(750, 810, 40, 130)); var currentRoom = 0; var x=0, y=20; var playerX = 0; var playerY = 0; var playerNextX = 0; var playerNextY = 0; var playerFacing = 0; var playerSpeed = 2; let floor_texture; let wall_texture; let door_texture; function preload() { f = loadFont(\u0026#39;https://cdnjs.cloudflare.com/ajax/libs/ink/3.1.10/fonts/Roboto/roboto-regular-webfont.ttf\u0026#39;); floor_texture = loadImage(\u0026#39;/VisualComputing/sketches/textures_models/floor_texture.jpeg\u0026#39;); wall_texture = loadImage(\u0026#39;/VisualComputing/sketches/textures_models/wall1_texture.jpg\u0026#39;); door_texture = loadImage(\u0026#39;/VisualComputing/sketches/textures_models/wall6_texture.jpg\u0026#39;); modelPlayer = loadModel(\u0026#39;/VisualComputing/sketches/textures_models/player.obj\u0026#39;); modelCharizard = loadModel(\u0026#39;/VisualComputing/sketches/textures_models/charizard.obj\u0026#39;); textureCharizard = loadImage(\u0026#39;/VisualComputing/sketches/textures_models/charizard.jpg\u0026#39;); modelBulbasaur = loadModel(\u0026#39;/VisualComputing/sketches/textures_models/bulbasaur.obj\u0026#39;); textureBulbasaur = loadImage(\u0026#39;/VisualComputing/sketches/textures_models/bulbasaur.jpg\u0026#39;); modelSquirtle = loadModel(\u0026#39;/VisualComputing/sketches/textures_models/squirtle.obj\u0026#39;); textureSquirtle = loadImage(\u0026#39;/VisualComputing/sketches/textures_models/squirtle.jpg\u0026#39;); modelScyther = loadModel(\u0026#39;/VisualComputing/sketches/textures_models/scyther.obj\u0026#39;); textureScyther = loadImage(\u0026#39;/VisualComputing/sketches/textures_models/scyther.jpg\u0026#39;); } document.oncontextmenu = function() { return false; } var easycam1, easycam2; function setup() { frameRate(30) var w = 800; var h = 800; var canvas = createCanvas(w, h, WEBGL); var graphics1 = createGraphics(w, h, WEBGL) var graphics2 = createGraphics(w, h, WEBGL); easycam1 = new Dw.EasyCam(graphics1._renderer); easycam2 = new Dw.EasyCam(graphics2._renderer); easycam1.setState(cams[0], 0); easycam2.setState({distance: 100, center : [0, 0, 0], rotation : [0, 0, 0, 1]}, 0); //easycam1.attachMouseListeners(this._renderer); //easycam2.attachMouseListeners(this._renderer); // set viewports easycam1.setViewport([0,0,w,h]); easycam2.setViewport([Math.floor(3*w/4),0,Math.floor(w/4),Math.floor(h/4)]); } function draw(){ clear(); easycam2.setCenter([playerX, playerY, 0], 0); playerNextX = playerX; playerNextY = playerY; for (let i = 0; i \u0026lt; rooms.length; i++) { if (rooms[i].X1 \u0026lt;= playerX \u0026amp;\u0026amp; playerNextX \u0026lt;= rooms[i].X2 \u0026amp;\u0026amp; rooms[i].Y1 \u0026lt;= playerY \u0026amp;\u0026amp; playerY \u0026lt;= rooms[i].Y2) { easycam1.setState(cams[i], 0); currentRoom = i; currentCam = i; break; } } if (keyIsPressed === true) { switch(keyCode) { case 87://W playerNextY = playerY + playerSpeed; playerFacing = 2; break; case 83://S playerNextY = playerY - playerSpeed; playerFacing = 0; break; case 68://D playerNextX = playerX - playerSpeed; playerFacing = 3; break; case 65://A playerNextX = playerX + playerSpeed; playerFacing = 1; break; case 69://E playerSpeed = playerSpeed + 0.1; break; case 81://Q playerSpeed = playerSpeed - 0.1; break; default: } } for (let i = 0; i \u0026lt; walls.length; i++) { if (walls[i].tlY-(walls[i].sY/2) \u0026lt; playerNextY+5 \u0026amp;\u0026amp; playerNextY-5 \u0026lt; walls[i].tlY+(walls[i].sY/2) \u0026amp;\u0026amp; walls[i].tlX-(walls[i].sX/2) \u0026lt; playerNextX+5 \u0026amp;\u0026amp; playerNextX-5 \u0026lt; walls[i].tlX+(walls[i].sX/2)) { playerNextY = playerY playerNextX = playerX } } playerX = playerNextX playerY = playerNextY var g1 = easycam1.graphics; var g2 = easycam2.graphics; g1.clear(); g2.clear(); // projection g1.perspective(60 * PI/180, width/height, 1, 5000); // BG g1.background(32); g1.noStroke(); // lights g1.ambientLight(10); g1.pointLight(35, 30, 30, 0, 0, 100); //floor g1.push(); g1.translate(0, 0, 0); g1.ambientMaterial(255,255,255); g1.texture(floor_texture); g1.box(2000, 1200, 1); g1.pop(); // player g1.push(); g1.translate(playerX, playerY, 0); g1.ambientMaterial(0,0,0); g1.scale(2); g1.rotateX(PI/2*(-3)); g1.rotateY(playerFacing*PI/2*(-3)); g1.model(modelPlayer); //g1.box(10, 10, 30); g1.pop(); // Charizard g1.push(); g1.translate(230, 380, 12); g1.ambientMaterial(0,0,0); g1.scale(0.15); g1.texture(textureCharizard); g1.rotateX(PI/2*(-0.9)); g1.rotateY(PI/2*(-2)); g1.model(modelCharizard); g1.pop(); // Bulbasaur g1.push(); g1.translate(-800, 0, 0); g1.ambientMaterial(0,0,0); g1.scale(0.05); g1.texture(textureBulbasaur); g1.rotateX(PI/2*(-1)); g1.rotateY(PI/2*(1)); g1.model(modelBulbasaur); g1.pop(); // Squirtle g1.push(); g1.translate(755, 60, 0); g1.ambientMaterial(0,0,0); g1.scale(0.10); g1.texture(textureSquirtle); g1.rotateX(PI/2*(-0.9)); g1.rotateY(PI/2*(-1.6)); g1.model(modelSquirtle); g1.pop(); // Scyther g1.push(); g1.translate(-360, 90, 22); g1.ambientMaterial(0,0,0); g1.scale(0.17); g1.texture(textureScyther); g1.rotateX(PI/2*(-1)); g1.rotateY(PI/2*(1)); g1.model(modelScyther); g1.pop(); for (let i = 0; i \u0026lt; walls.length; i++) { g1.push(); g1.translate(walls[i].tlX, walls[i].tlY, 50); g1.ambientMaterial(walls[i].r, walls[i].g, walls[i].b); g1.box(walls[i].sX, walls[i].sY, 100); g1.pop(); } g2.ortho(-width/7, width/7, -height/7, height/7); // BG g2.background(32); g2.noStroke(); // lights // g2.ambientLight(35); // g2.pointLight(10, 10, 10, 0, 0, 50); //floor // g2.push(); // g2.translate(0, 0, 0); // g2.ambientMaterial(255,255,255); // g2.box(2000, 1200, 1); // g2.pop(); // player g2.push(); g2.translate(playerX, playerY, 15.5); g2.ambientMaterial(0,0,0); g2.box(10, 10, 30); g2.pop(); for (let i = 0; i \u0026lt; walls.length; i++) { g2.push(); g2.translate(walls[i].tlX, walls[i].tlY, 50); g2.ambientMaterial(walls[i].r, walls[i].g, walls[i].b); g2.box(walls[i].sX, walls[i].sY, 100); g2.pop(); } // 2D screen-aligned rendering section easycam1.beginHUD(); let state = easycam1.getState(); // Render the background box for the HUD g1.noStroke(); g1.fill(50,50,52, 200); // a bit of transparency g1.rect(x+20,y,380,200); // use the loaded font g1.textFont(f); g1.textSize(16); g1.stroke(50,50,52); g1.strokeWeight(0.5); // Render the labels g1.fill(69,161,255); g1.text(\u0026#34;Camera:\u0026#34;,x+35,y+25); g1.text(\u0026#34;Room:\u0026#34;,x+35,y+25+20); g1.text(\u0026#34;Distance:\u0026#34;,x+35,y+25+40); g1.text(\u0026#34;Center: \u0026#34;,x+35,y+25+60); g1.text(\u0026#34;Rotation:\u0026#34;,x+35,y+25+80); g1.text(\u0026#34;Framerate:\u0026#34;,x+35,y+25+100); g1.text(\u0026#34;playerX:\u0026#34;,x+35,y+25+120); g1.text(\u0026#34;playerY:\u0026#34;,x+35,y+25+140); g1.text(\u0026#34;playerSpeed:\u0026#34;,x+35,y+25+160); // Render the state numbers g1.fill(69,161,255); g1.text(currentCam,x+125,y+25); g1.text(currentRoom,x+125,y+25+20); g1.text(nfs(state.distance, 1, 2),x+125,y+25+40); g1.text(nfs(state.center, 1, 2),x+125,y+25+60); g1.text(nfs(state.rotation, 1, 3),x+125,y+25+80); g1.text(nfs(frameRate(), 1, 2),x+125,y+25+100); g1.text(nfs(playerX, 1, 2),x+125,y+25+120); g1.text(nfs(playerY, 1, 2),x+125,y+25+140); g1.text(nfs(playerSpeed, 1, 2),x+125,y+25+160); easycam1.endHUD(); // display results displayResult_WEBGL(); } // use this, when the main canvas is WEBGL ... createCanvas(w,h,WEBGL) function displayResult_WEBGL(){ var vp1 = easycam1.getViewport(); var vp2 = easycam2.getViewport(); resetMatrix(); ortho(0, width, -height, 0, -Number.MAX_VALUE, +Number.MAX_VALUE); texture(easycam1.graphics); rect(vp1[0], vp1[1], vp1[2], vp1[3]); texture(easycam2.graphics); rect(vp2[0], vp2[1], vp2[2], vp2[3]); } Conclusiones # Es posible crear un entorno 3D virtual con solo dos dimensiones, controlando los ángulos implicados en el proceso y evitando la deformación espacial por las perspectivas, existen librerias especificas para este propósito, entre ellas están EasyCam que ya han hecho todo el trabajo matemático para permitir crear estos entornos con instrucciones simplificadas. References # EasyCam https://github.com/freshfork/p5.EasyCam Carratalá Rocío, Tomado de http://repositori.uji.es/xmlui/bitstream/handle/10234/139036/TFG_2015_CarratalaSaezR.pdf?sequence=1 "},{"id":3,"href":"/VisualComputing/docs/taller-1/convolucion/","title":"Convolución","section":"Taller 1","content":" Marco Teorico # Convolución # 1. Identity: La mascara retorna la misma imagen\n\\[\\begin{bmatrix} 0 \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; 1 \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; 0 \\end{bmatrix}\\] 2. Sharpen: El núcleo de nitidez enfatiza las diferencias en los valores de píxeles adyacentes, lo que hace que la imagen parezca más vívida.\n\\[\\begin{bmatrix} 0 \u0026amp; -1 \u0026amp; 0\\\\ -1 \u0026amp; 5 \u0026amp; -1\\\\ 0 \u0026amp; -1 \u0026amp; 0 \\end{bmatrix}\\] 3. Emboss: Es una técnica de gráficos por computadora en la que cada píxel de una imagen se reemplaza por un resaltado o una sombra, según los límites claros/oscuros de la imagen original. Las áreas de bajo contraste se reemplazan por un fondo gris\n\\[\\begin{bmatrix} -2 \u0026amp; -1 \u0026amp; 0\\\\ -1 \u0026amp; 2 \u0026amp; 1\\\\ 0 \u0026amp; 1 \u0026amp; 2 \\end{bmatrix}\\] 4. Outline:\n\\[\\begin{bmatrix} -1 \u0026amp; -1 \u0026amp; -1\\\\ -1 \u0026amp; 9 \u0026amp; -1\\\\ -1 \u0026amp; 1 \u0026amp; -1 \\end{bmatrix}\\] 5. Gaussian-blur: es el resultado de desenfocar una imagen por una función gaussiana (llamada así por el matemático y científico Carl Friedrich Gauss).\n\\[\\begin{bmatrix} 1 \u0026amp; 2 \u0026amp; 1\\\\ 2 \u0026amp; 4 \u0026amp; 1\\\\ 1 \u0026amp; 2 \u0026amp; 1 \\end{bmatrix}\\] El operador Sobel es utilizado en procesamiento de imágenes, especialmente en algoritmos de detección de bordes. Técnicamente es un operador diferencial discreto que calcula una aproximación al gradiente de la función de intensidad de una imagen. Para cada punto de la imagen a procesar, el resultado del operador Sobel es tanto el vector gradiente correspondiente como la norma de este vector.\n6. Left-sobel:\n\\[\\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; -1\\\\ 2 \u0026amp; 1 \u0026amp; -2\\\\ 1 \u0026amp; 0 \u0026amp; -1 \\end{bmatrix}\\] 7. Right-sobel:\n\\[\\begin{bmatrix} -1 \u0026amp; 0 \u0026amp; 1\\\\ -2 \u0026amp; 1 \u0026amp; 2\\\\ -1 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}\\] 8. Top-sobel:\n\\[\\begin{bmatrix} 1 \u0026amp; 2 \u0026amp; 1\\\\ 0 \u0026amp; 1 \u0026amp; 0\\\\ -1 \u0026amp; -2 \u0026amp; -1 \\end{bmatrix}\\] 9. Botton-sobel:\n\\[\\begin{bmatrix} -1 \u0026amp; -2 \u0026amp; -1\\\\ 0 \u0026amp; 1 \u0026amp; 0\\\\ 1 \u0026amp; 2 \u0026amp; 1 \\end{bmatrix}\\] Ejercicio # Ejecuciòn Còdigo Lightness # Se utilizaron las siguientes ecuaciones para calcular la constante por la cual se multiplicó el calor de cada pixel.\nHSI\n\\(L = \\frac{1}{3}\\times(cR \u0026#43; cG \u0026#43; cB) \\to c = \\frac{3L}{(R \u0026#43; G \u0026#43; B)}\\) HSV\n\\(L = \\max(cR, cG, cB) \\to c = \\frac{L}{\\max(R, G, B)}\\) HSL\n\\(L = \\frac{1}{2}\\times(\\max(cR, cG, cB) \u0026#43; \\min(cR, cG, cB)) \\to c = \\frac{2L}{\\max(R, G, B) \u0026#43; \\min(R, G, B)}\\) Luma (601)\n\\(L = 0.2989cR \u0026#43; 0.5870cG \u0026#43; 0.1140cB \\to c = \\frac{L}{0.2989R \u0026#43; 0.5870G \u0026#43; 0.1140B}\\) Código # \u0026lt;img hidden id=\u0026#34;uploaded-image\u0026#34; src=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;!--imagen subida, de ella se obtiene la representación binaria que luego es usada por el canvas para obtener la representación en RGBA --\u0026gt; \u0026lt;canvas hidden id=\u0026#34;canvas-for-rgba\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; \u0026lt;!-- canvas solo para dibujar la imagen subida y obtener la representación en RGBA, por eso puede ser oculta --\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; id=\u0026#34;image-input\u0026#34; accept=\u0026#34;image/jpeg, image/png, image/jpg\u0026#34;\u0026gt; Kernel: \u0026lt;select id=\u0026#34;kernel-select\u0026#34;\u0026gt; \u0026lt;option selected value=\u0026#34;identity\u0026#34;\u0026gt;Identity\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;gaussian-blur\u0026#34;\u0026gt;Gaussian Blur\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;sharpen\u0026#34;\u0026gt;Sharpen\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;outline\u0026#34;\u0026gt;Outline\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;emboss\u0026#34;\u0026gt;Emboss\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;left-sobel\u0026#34;\u0026gt;Left Sobel\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;right-sobel\u0026#34;\u0026gt;Right Sobel\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;top-sobel\u0026#34;\u0026gt;Top Sobel\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;bottom-sobel\u0026#34;\u0026gt;Bottom Sobel\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;input hidden id=\u0026#34;lightness-input\u0026#34; type=\u0026#34;number\u0026#34; placeholder=\u0026#34;Lightness\u0026#34;\u0026gt;\u0026lt;/input\u0026gt; \u0026lt;select hidden id=\u0026#34;lightness-definition-select\u0026#34;\u0026gt; \u0026lt;option selected value=\u0026#34;HSI\u0026#34;\u0026gt;HSI\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;HSV\u0026#34;\u0026gt;HSV\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;HSL\u0026#34;\u0026gt;HSL\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;Luma 601\u0026#34;\u0026gt;Luma 601\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;Luma 240\u0026#34;\u0026gt;Luma 240\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;Luma 709\u0026#34;\u0026gt;Luma 709\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;Luma 2020\u0026#34;\u0026gt;Luma 2020\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;canvas id=\u0026#34;transformed-image-canvas\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; \u0026lt;!-- Load d3.js --\u0026gt; \u0026lt;script src=\u0026#34;https://d3js.org/d3.v4.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- Create a div where the graph will take place --\u0026gt; \u0026lt;div id=\u0026#34;red-histogram\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;green-histogram\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;blue-histogram\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; function bound(color) { if (color \u0026gt; 255) return 255 else if (color \u0026lt; 0) return 0 return color } function applyLightness(image, width, height) { let L = document.querySelector(\u0026#39;#lightness-input\u0026#39;).value if (L == \u0026#39;\u0026#39;) return; let canvas = document.querySelector(\u0026#34;#canvas-for-rgba\u0026#34;); canvas.width = width; canvas.height = height; var ctx = canvas.getContext(\u0026#34;2d\u0026#34;); ctx.drawImage(image, 0, 0); var data = ctx.getImageData(0, 0, width, height).data; lightness_data = [] let R_array = [] let G_array = [] let B_array = [] let def = document.querySelector(\u0026#39;#lightness-definition-select\u0026#39;).value for (let i = 0; i \u0026lt; data.length; i += 4) { let r = data[i]; let g = data[i + 1]; let b = data[i + 2]; let a = data[i + 3]; let c = constant(L, r, g, b, def) let cr = c * r let cg = c * g let cb = c * b let R = bound(Math.round(cr)) let G = bound(Math.round(cg)) let B = bound(Math.round(cb)) let A = a R_array.push(R) G_array.push(G) B_array.push(B) lightness_data.push(R) lightness_data.push(G) lightness_data.push(B) lightness_data.push(A) } canvas = document.querySelector(\u0026#34;#transformed-image-canvas\u0026#34;); canvas.width = width; canvas.height = height; ctx = canvas.getContext(\u0026#34;2d\u0026#34;); var imageData = canvas.getContext(\u0026#39;2d\u0026#39;).createImageData(width, height); imageData.data.set(lightness_data); ctx.putImageData(imageData, 0, 0) drawHistogram(R_array, \u0026#39;red\u0026#39;); drawHistogram(G_array, \u0026#39;green\u0026#39;); drawHistogram(B_array, \u0026#39;blue\u0026#39;); } // función de procesamiento de la imagen function processImage(image, width, height) { let canvas = document.querySelector(\u0026#34;#canvas-for-rgba\u0026#34;); canvas.width = width; canvas.height = height; var ctx = canvas.getContext(\u0026#34;2d\u0026#34;); ctx.drawImage(image, 0, 0); var data = ctx.getImageData(0, 0, width, height).data; // data es un arreglo con los valores RGBA de la imagen (arreglo unidimensional) transformed_data = [] // es el arreglo transformado o procesado let ker = kernel(document.querySelector(\u0026#39;#kernel-select\u0026#39;).value) // kernel a usar let R_array = [] let G_array = [] let B_array = [] for (let i = 0; i \u0026lt; data.length; i += 4) { // se itera de 4, i corresponde al valor R del pixel i-ésimo de la imagen let r = data[i]; let g = data[i + 1]; let b = data[i + 2]; let a = data[i + 3]; let pos = position(i, width, height) let nbs = neighbours(i, pos, width) let ws = weights(ker, pos) let sum = ws.reduce((partialSum, a) =\u0026gt; partialSum + a, 0); // en la matriz se debe garantizar que la suma de los pesos no sea cero para que funcione let rtotal = 0 let gtotal = 0 let btotal = 0 let atotal = 0 // suma ponderada para cada valor R G B A for (let j = 0; j \u0026lt; nbs.length; j++) { rtotal += data[nbs[j]] * ws[j] gtotal += data[nbs[j] + 1] * ws[j] btotal += data[nbs[j] + 2] * ws[j] atotal += data[nbs[j] + 3] * ws[j] } // se obtiene la suma ponderada: error cuando sum es cero ... let R = Math.round(rtotal / sum) let G = Math.round(gtotal / sum) let B = Math.round(btotal / sum) let A = Math.round(atotal / sum) R_array.push(R) G_array.push(G) B_array.push(B) // se agregan los nuevos valores al arreglo transformado transformed_data.push(R) transformed_data.push(G) transformed_data.push(B) transformed_data.push(A) } // se crea canvas de la imagen transformada para mostrarla en pantalla // nota: se necesita usar canvas para poder visualizar la imagen apartir del arreglo de R G B A canvas = document.querySelector(\u0026#34;#transformed-image-canvas\u0026#34;); canvas.width = width; canvas.height = height; ctx = canvas.getContext(\u0026#34;2d\u0026#34;); var imageData = canvas.getContext(\u0026#39;2d\u0026#39;).createImageData(width, height); imageData.data.set(transformed_data); ctx.putImageData(imageData, 0, 0) drawHistogram(R_array, \u0026#39;red\u0026#39;); drawHistogram(G_array, \u0026#39;green\u0026#39;); drawHistogram(B_array, \u0026#39;blue\u0026#39;); } // se procesa imagen cuando se sube archivo const image_input = document.querySelector(\u0026#34;#image-input\u0026#34;); image_input.addEventListener(\u0026#34;change\u0026#34;, function() { const reader = new FileReader(); reader.readAsDataURL(this.files[0]); reader.onload = (e) =\u0026gt; { const image = new Image(); image.src = e.target.result; image.onload = (e) =\u0026gt; { const width = e.target.width; const height = e.target.height; const uploaded_image = reader.result document.querySelector(\u0026#34;#uploaded-image\u0026#34;).src = uploaded_image; processImage(image, width, height) document.querySelector(\u0026#39;#lightness-input\u0026#39;).removeAttribute(\u0026#34;hidden\u0026#34;); document.querySelector(\u0026#39;#lightness-definition-select\u0026#39;).removeAttribute(\u0026#39;hidden\u0026#39;) }; }; }); // se procesa imagen cuando se cambia el valor del select kernel const kernel_select = document.querySelector(\u0026#34;#kernel-select\u0026#34;); kernel_select.addEventListener(\u0026#34;change\u0026#34;, function() { const image = new Image(); let img = document.querySelector(\u0026#34;#uploaded-image\u0026#34;) image.src = img.src; let width = img.width let height = img.height processImage(image, width, height) }); // se procesa imagen cuando se cambia el valor del select kernel const lightness_input = document.querySelector(\u0026#34;#lightness-input\u0026#34;); lightness_input.addEventListener(\u0026#34;change\u0026#34;, function() { const image = new Image(); let img = document.querySelector(\u0026#34;#uploaded-image\u0026#34;) image.src = img.src; let width = img.width let height = img.height applyLightness(image, width, height) }); // se procesa imagen cuando se cambia el valor del select kernel const lightness_definition_select = document.querySelector(\u0026#34;#lightness-definition-select\u0026#34;); lightness_definition_select.addEventListener(\u0026#34;change\u0026#34;, function() { const image = new Image(); let img = document.querySelector(\u0026#34;#uploaded-image\u0026#34;) image.src = img.src; let width = img.width let height = img.height applyLightness(image, width, height) }); // obtener posición del pixel según su índice y los valores weight y height let position = (i, w, h) =\u0026gt; { if (i == 0) return \u0026#39;top-left-corner\u0026#39;; else if (i == (w * 4) - 1) return \u0026#39;top-right-corner\u0026#39;; else if (i == h * ((w * 4) - 1)) return \u0026#39;bottom-left-corner\u0026#39;; else if (i == (h * w * 4) - 1) return \u0026#39;bottom-right-corner\u0026#39;; else if (i \u0026lt; (w * 4) - 1) return \u0026#39;top-row\u0026#39;; else if (i % (w * 4) == (w * 4) - 1) return \u0026#39;right-row\u0026#39;; else if (i \u0026gt; h * ((w * 4) - 1) \u0026amp;\u0026amp; i \u0026lt; (h * w * 4) - 1) return \u0026#39;bottom-row\u0026#39;; else if (i % (w * 4) == 0) return \u0026#39;left-row\u0026#39;; else return \u0026#39;inner-cell\u0026#39; } // arreglo de índices según posición, que será usado para obtener las posiciones de los pixeles vecinos (neighbours) y // las posiciones de los pesos de la matriz del kernel let indexes = (position) =\u0026gt; { if (position == \u0026#39;inner-cell\u0026#39;) return [0, 1, 2, 3, 4, 5, 6, 7, 8] else if (position == \u0026#39;left-row\u0026#39;) return [ 1, 2, 4, 5, 7, 8] else if (position == \u0026#39;right-row\u0026#39;) return [0, 1, 3, 4, 6, 7 ] else if (position == \u0026#39;top-row\u0026#39;) return [ 3, 4, 5, 6, 7, 8] else if (position == \u0026#39;bottom-row\u0026#39;) return [0, 1, 2, 3, 4, 5, ] else if (position == \u0026#39;top-right-corner\u0026#39;) return [ 3, 4, 6, 7 ] else if (position == \u0026#39;top-left-corner\u0026#39;) return [ 4, 5, 7, 8] else if (position == \u0026#39;bottom-left-corner\u0026#39;) return [ 1, 2, 4, 5 ] else if (position == \u0026#39;bottom-right-corner\u0026#39;) return [0, 1, 3, 4 ] else return [] } // arreglo con los índices de los pixeles vecinos let neighbours = (i, position, w) =\u0026gt; { let matrix = [i - (w * 4) - 4, i - (w * 4), i - (w * 4) + 4, i - 4, i , i + 4, i + (w * 4) - 4, i + (w * 4), i + (w * 4) + 4] let idx = indexes(position) let nbs = [] idx.forEach((i) =\u0026gt; { nbs.push(matrix[i]) }) return nbs } // kernels disponibles: cada matriz es una matriz de pesos let kernel = (kernel) =\u0026gt; { if (kernel == \u0026#39;identity\u0026#39;) return [0, 0, 0, 0, 1, 0, 0, 0, 0] else if (kernel == \u0026#39;gaussian-blur\u0026#39;) return [1, 2, 1, 2, 4, 1, 1, 2, 1] else if (kernel == \u0026#39;emboss\u0026#39;) return [-2, -1, 0, -1, 2, 1, 0, 1, 2] else if (kernel == \u0026#39;left-sobel\u0026#39;) return [1, 0, -1, 2, 1, -2, 1, 0, -1] else if (kernel == \u0026#39;right-sobel\u0026#39;) return [-1, 0, 1, -2, 1, 2, // se agregó 1 en la posición central para garantizar que suma de pesos no sea cero -1, 0, 1] else if (kernel == \u0026#39;top-sobel\u0026#39;) return [1, 2, 1, 0, 1, 0, -1, -2, -1] else if (kernel == \u0026#39;bottom-sobel\u0026#39;) return [-1, -2, -1, 0, 1, 0, 1, 2, 1] else if (kernel == \u0026#39;sharpen\u0026#39;) return [0, -1, 0, -1, 5, -1, 0, -1, 0] else if (kernel == \u0026#39;outline\u0026#39;) return [-1, -1, -1, -1, 9, -1, -1, 1, -1] else return [] } // arreglo de pesos que se usarán en la suma ponderada del pixel actual: depende del kernel y de la posición del pixel let weights = (ker, position) =\u0026gt; { let idx = indexes(position) let ws = [] idx.forEach((i) =\u0026gt; { ws.push(ker[i]) }) return ws } let constant = (L, R, G, B, definition) =\u0026gt; { if (definition == \u0026#39;HSI\u0026#39;) return 3 * (L / (R + G + B)) else if (definition == \u0026#39;HSV\u0026#39;) return L / Math.max(R, G, B) else if (definition == \u0026#39;HSL\u0026#39;) return 2 * (L / (Math.min(R, G, B) + Math.max(R, G, B))) else if (definition == \u0026#39;Luma 601\u0026#39;) return L / (0.2989 * R + 0.5870 * G + 0.1140 * B) else if (definition == \u0026#39;Luma 240\u0026#39;) return L / (0.212 * R + 0.701 * G + 0.087 * B) else if (definition == \u0026#39;Luma 709\u0026#39;) return L / (0.2126 * R + 0.7152 * G + 0.0722 * B) else if (definition == \u0026#39;Luma 2020\u0026#39;) return L / (0.2627 * R + 0.6780 * G + 0.0593 * B) else return 1 } function drawHistogram(data, color) { let colors = { \u0026#39;red\u0026#39;: \u0026#39;#FF0000\u0026#39;, \u0026#39;green\u0026#39;: \u0026#39;#00FF00\u0026#39;, \u0026#39;blue\u0026#39;: \u0026#39;#0000FF\u0026#39; } var domain = [0, 255] var margin = { top: 30, right: 30, bottom: 30, left: 50 }, width = 460 - margin.left - margin.right, height = 400 - margin.top - margin.bottom; var x = d3 .scaleLinear() .domain(domain) .range([0, width]); var histogram = d3 .histogram() .domain(x.domain()) .thresholds(x.ticks(256)); var bins = histogram(data); d3 .select(`#${color}-histogram svg`).remove() var svg = d3 .select(`#${color}-histogram`) .append(\u0026#34;svg\u0026#34;) .attr(\u0026#34;width\u0026#34;, width + margin.left + margin.right) .attr(\u0026#34;height\u0026#34;, height + margin.top + margin.bottom) .append(\u0026#34;g\u0026#34;) .attr(\u0026#34;transform\u0026#34;, \u0026#34;translate(\u0026#34; + margin.left + \u0026#34;,\u0026#34; + margin.top + \u0026#34;)\u0026#34;); svg .append(\u0026#34;g\u0026#34;) .attr(\u0026#34;transform\u0026#34;, \u0026#34;translate(0,\u0026#34; + height + \u0026#34;)\u0026#34;) .call(d3.axisBottom(x)); var y = d3 .scaleLinear() .range([height, 0]) .domain([ 0, d3.max(bins, function(d) { return d.length; }) ]); svg.append(\u0026#34;g\u0026#34;).call(d3.axisLeft(y)); svg .selectAll(\u0026#34;rect\u0026#34;) .data(bins) .enter() .append(\u0026#34;rect\u0026#34;) .attr(\u0026#34;x\u0026#34;, 1) .attr(\u0026#34;transform\u0026#34;, function(d) { return \u0026#34;translate(\u0026#34; + x(d.x0) + \u0026#34;,\u0026#34; + y(d.length) + \u0026#34;)\u0026#34;; }) .attr(\u0026#34;width\u0026#34;, function(d) { return x(d.x1) - x(d.x0) - 1; }) .attr(\u0026#34;height\u0026#34;, function(d) { return height - y(d.length); }) .style(\u0026#34;fill\u0026#34;, colors[color]); } \u0026lt;/script\u0026gt; "},{"id":4,"href":"/VisualComputing/docs/taller-2/W2_Optional/","title":"Ejercicio Opcional","section":"Taller 2","content":" Workshop 02 - Optional Exercises # Exercise # Implement in software any of the visualizations: primitive rasterization, color shading, z-depth, texture-mapping and/or anti-aliasing (requires a bit of research).\nPrimitive Rasterization + Color Shading # Press any key to switch between triangles\nImplementation Details # Declarations # We declare a variable w that will be each pixel width and height. We declare a variable mid as w/2 to facilitate draawing lines from the center of a pixel. We declare the triangle vertexes coordinates as xA, yB, xB, \u0026hellip; We declare three color pickers: one per vertex. Declarations Code let mid = 12.5; // to draw lines from center point of each pixel let w = 25; // pixel width and height // triangle lines coordinates let xA = 4; let yA = 4; let xB = 10; let yB = 10; let xC = 4; let yC = 15; let pixels; let colors; // color pickers let cpA let cpB let cpC Setup # The canvas of 500 x 500 will be a 20 x 20 pixels grid. The color pickers are instantiated with initial colors (R, G, B). The grid lines will light green. Setup Code function setup() { createCanvas(500, 500); // 500 / 25 for a 20x20 pixels grid R = color(220, 10, 10); // red cpA = createColorPicker(R); cpA.position(0, height + 5); G = color(10, 220, 10); // green cpB = createColorPicker(G); cpB.position(50, height + 5); B = color(10, 10, 220); // blue cpC = createColorPicker(B); cpC.position(100, height + 5); LG = color(100, 150, 10); // light green for pixels stroke } Draw # Colors are updated based on the colors pickers values. The grid of 20x20 black pixels is painted. Some of those pixels are then re-painted in colors to display the triangle. The triangle vertexes pixels are painted using the current color pickers colors. The sides AB, BC, CA are painted. To paint a side, we run rasterization Bresenham\u0026rsquo;s line algorithm. Bresenham\u0026rsquo;s algorithm returns a list of pixels coordinates. Those pixels are the ones covered by the triangle side. We know the vertexes colors for the side that is being painted. From Bresenham\u0026rsquo;s algorithm we now know the side length in terms of pixels. We both vertexes colors and side length in pixels we can perform interpolation to do the shading. Interolation generated colors are stored in a dictionary COLORS, because they will be needed when painting inner pixels. An array named PIXELS will contain all sides pixels. They will be needed when painting inner pixels. The inner pixels painting consists of iterating row by row belonging to the triangle (top to bottom). For each row, we get the left most pixel and right most pixel colors. With these extremes pixels coordinates, we can calculate the row length. Both colors and the row length is then used by the interpolation method to generate the colors of inner pixels. Inner pixels are painted. Triangle \u0026ldquo;continous\u0026rdquo; lines are painted from the center of each vertex pixel to the center of each vertex pixel. Draw Code function draw() { // colors will be set based on color pickers R = cpA.color() G = cpB.color() B = cpC.color() fill(0); // black background stroke(LG); // a light green grid // we draw black squares (pixels) of width and height 25 for (let i = 0; i \u0026lt; 500; i += w) { for (let j = 0; j \u0026lt; 500; j += w) { square(i, j, w); } } // we draw triangle vertexes points (A, B, C) fill(R); square(xA*w, yA*w, w); fill(G); square(xB*w, yB*w, w); fill(B); square(xC*w, yC*w, w); let PIXELS = [] // will contain triangle sides pixels coordinates let COLORS = {} // will contain triangle sides pixels colors (key: [r-c] -\u0026gt; value: color) // SIDES PAINTING // SIDE AB pixels = bresenham(xA, yA, xB, yB) // apply bresenham to get sides pixels coordinates colors = interpolate(R, G, pixels.length) // interpolate using side length and vertexes colors for (let i = 0; i \u0026lt; pixels.length; i++) { COLORS[`[${pixels[i].x}-${pixels[i].y}]`] = colors[i] // we store colors because we will need them to paint inner pixels (this may have been unnecessary) // we paint side pixels based on bresenham and interpolation results fill(colors[i]); square(pixels[i].x*w, pixels[i].y*w, w); } PIXELS = PIXELS.concat(pixels) // we will have duplicates pixels (vertex and maybe others) // SIDE BC pixels = bresenham(xB, yB, xC, yC) colors = interpolate(G, B, pixels.length) for (let i = 0; i \u0026lt; pixels.length; i++) { COLORS[`[${pixels[i].x}-${pixels[i].y}]`] = colors[i] fill(colors[i]); square(pixels[i].x*w, pixels[i].y*w, w); } PIXELS = PIXELS.concat(pixels) // SIDE CA pixels = bresenham(xC, yC, xA, yA) colors = interpolate(B, R, pixels.length) for (let i = 0; i \u0026lt; pixels.length; i++) { COLORS[`[${pixels[i].x}-${pixels[i].y}]`] = colors[i] fill(colors[i]); square(pixels[i].x*w, pixels[i].y*w, w); } PIXELS = PIXELS.concat(pixels) // it containes sides pixels coordinates (with some duplicates, but it\u0026#39;s ok with lmp == rmp condition check below in the code) // INNER PIXELS PAINTING // we iterate vertically row by row covering the triangle let minY = Math.min(yA, yB, yC); // indicates row to start with let maxY = Math.max(yA, yB, yC); // indicates row to end with for (let row = minY; row \u0026lt;= maxY; row++) { let limits = PIXELS.filter((p) =\u0026gt; p.y == row); // sides pixels belonging to this row let lmp = limits.reduce((a, b) =\u0026gt; (a.x \u0026lt; b.x) ? a : b) // left most pixel let rmp = limits.reduce((a, b) =\u0026gt; (a.x \u0026gt; b.x) ? a : b) // right most pixel // lmp and rmp colors will be used in interpolation if (lmp == rmp) // if both equal, there\u0026#39;s only one pixel in this row and we don\u0026#39;t need to paint any inner pixel continue; let rowpixels = []; // will contain pixels to fill the row let ip = rmp.x - lmp.x - 1; // intermediate pixels count // if consecutive, it\u0026#39;s 0 and for loop below won\u0026#39;t run (no inner pixels to paint) rowpixels.push(lmp) // we add first pixel in row // won\u0026#39;t run if no intermediate pixels for (let i = 1; i \u0026lt;= ip; i++) { rowpixels.push({x:lmp.x + i, y:row}) // y is fixed, but x will be incremented from x + 1 to x + ip so that limits are ignored since they are added outside the loop } rowpixels.push(rmp) // we add last pixel in row // we add it here to conserve order // COLORS dict lookup to get colors and start interpolation let lmc = COLORS[`[${lmp.x}-${lmp.y}]`] // left most color let rmc = COLORS[`[${rmp.x}-${rmp.y}]`] // right most color colors = interpolate(lmc, rmc, rowpixels.length) // we interpolate using lmc, rmc and row length for (let i = 0; i \u0026lt; rowpixels.length; i++) { // we paint based on interpolation (no bresenham needed here) fill(colors[i]); square(rowpixels[i].x*w, rowpixels[i].y*w, w); } } // \u0026#34;CONTINUOUS\u0026#34; LINES PAINTING push(); stroke(10, 200, 200); strokeWeight(5); // we use mid so that lines start and end at the center of each vertex pixel line(xA*w + mid, yA*w + mid, xB*w + mid, yB*w + mid); line(xB*w + mid, yB*w + mid, xC*w + mid, yC*w + mid); line(xC*w + mid, yC*w + mid, xA*w + mid, yA*w + mid); pop(); } Bresenham\u0026rsquo;s line algorithm implementation # This implementation was translated to JavaScript from an implementation written in Python available at: encukou Bresenham\u0026rsquo;s line algorithm Python implementation Bresenham\u0026rsquo;s line algorithm Code function bresenham(x0, y0, x1, y1) { let dx = x1 - x0 let dy = y1 - y0 let xx let xy let yx let yy let xsign = (dx \u0026gt; 0) ? 1 : -1 let ysign = (dy \u0026gt; 0) ? 1 : -1 dx = Math.abs(dx) dy = Math.abs(dy) if (dx \u0026gt; dy) { xx = xsign xy = 0 yx = 0 yy = ysign } else { temp = dx dx = dy dy = temp xx = 0 xy = ysign yx = xsign yy = 0 } let D = 2*dy - dx let y = 0 let pixels = [] for (let x = 0; x \u0026lt; dx + 1; x++) { pixels.push({x: x0 + x*xx + y*yx, y: y0 + x*xy + y*yy}) if (D \u0026gt;= 0) { y += 1 D -= 2*dx } D += 2*dy } return pixels } Shading Interpolation implementation # This function was written based on a rasterization algorithm explainer found in YouTube and available at: Cédric Girardin (HuCE - cpvrLab) - Rasterizer Algorithm Explanation\nThe intuitive idea behind the linear interpolation can be grasped with the help of below image:\nShading Interpolation Code function interpolate(c0, c1, n) { let colors = [] let r0 = c0._getRed() // color 0 red let g0 = c0._getGreen() // color 0 green let b0 = c0._getBlue() // color 0 blue let r1 = c1._getRed() // color 1 red let g1 = c1._getGreen() // color 1 green let b1 = c1._getBlue() // color 1 blue for (let i = 0; i \u0026lt; n; i++) { d = n - 1; // denominator n0 = d - i; // color 0 numerator n1 = i; // color 1 numerator ratio_0 = n0 / d; ratio_1 = n1 / d; scaled_r0 = ratio_0 * r0; // scaled red 0 scaled_g0 = ratio_0 * g0; // scaled green 0 scaled_b0 = ratio_0 * b0; // scaled blue 0 scaled_r1 = ratio_1 * r1; // scaled red 0 scaled_g1 = ratio_1 * g1; // scaled green 0 scaled_b1 = ratio_1 * b1; // scaled blue 0 interpolated_r = scaled_r0 + scaled_r1; interpolated_g = scaled_g0 + scaled_g1; interpolated_b = scaled_b0 + scaled_b1; colors.push(color(interpolated_r, interpolated_g, interpolated_b)); } return colors } Auxiliary Functions # Any time a key is pressed, vertex coordinates are updated based on a random integer method with max being inclusive. Auxiliary Functions Code // new vertex coordinates are generated when pressing a key function keyPressed() { xA = randomint(0, 19); yA = randomint(0, 19); xB = randomint(0, 19); yB = randomint(0, 19); xC = randomint(0, 19); yC = randomint(0, 19); } // auxiliary function to get random integers (inclusive) function randomint(min, max) { min = Math.ceil(min); max = Math.floor(max); return Math.floor(Math.random() * (max - min + 1) + min); // inclusive } Z-buffer # Press any key to visualize z-buffer.\nPress any key again to deactivate it.\nImplementation Details # Declarations # P is the position of the camara in the 3D space. positions contains the position of each box at any moment. zbuffer contains distance from each box to the camera position P at any moment. colors contains the interpolated gray scale color of each box at any moment P. Declarations Code let angle = 0; // angle for boxes rotation let positions = [ // will contain boxes 3D positions ]; let zbuffer = [] // will contain distance between camera and each box. let colors = []; // will contain colors of boxes at any moment. let active = false; // flag to indicate z-buffer is being visualized let easycam; let P; // camera position let t = 0; // time counter just to play with ligths transitions // lights colors let R1 = 255; let G1 = 255; let B1 = 255; let R2 = 255; let G2 = 255; let B2 = 255; Setup # The camara starting position is (0, 0, 600). 50 boxes are placed throughout the space at random positions. Boxes positions are stored in array positions Setup Code function setup() { createCanvas(500, 500, WEBGL); easycam = createEasyCam(); // camera distance from center (0, 0, 0) will be 600. // when applying the quaternion (1, 0, 0, 0) with qpq\u0026#39; operation, camera will be in (0, 0, 600) position as expected. let state = { distance: 600, center: [0, 0, 0], rotation: [1, 0, 0, 0], // p=(0, 0, 600) =\u0026gt; qpq\u0026#39;=(0, 0, 600) }; easycam.setState(state, 1000); // 50 boxes are placed throughout the space with random positions. for (let i = 0; i \u0026lt; 50; i++) { let x = randomint(-250, 250); let y = randomint(-250, 250); let z = randomint(-250, 250); positions.push([x, y, z]); // positions are stored. } } Draw # Z-buffer visualization drawing consists of: Getting the camera position P. Updating the zbuffer by calculating distances from boxes to P. Updating the colors array by interpolating using some given thresholds. With colors array being updated, each box is painted. Draw Code function draw() { P = easycam.getPosition(); // P is the camera position. updateZBuffer(); // update Z-buffer function stores the distance between camera and each point in the zbuffer array. updateColors(); // based on the zbuffer values, each box will have a color calculated via interpolation. background(50); if (!active) { // if z-buffer is not being visualized, lights colores are updated every so often. let locX = mouseX - height / 2; let locY = mouseY - width / 2; if (t % 300 == 0) { R1 = randomint(0, 255); G1 = randomint(0, 255); B1 = randomint(0, 255); } else if (t % 151 == 0) { R2 = randomint(0, 255); G2 = randomint(0, 255); B2 = randomint(0, 255); } ambientLight(60, 60, 60); // 3 lights are being used pointLight(R1, G1, B1, 0, 0, 0); // center light pointLight(R2, G2, B2, locX, locY, 250); // mouse driven light pointLight(B2, R1, G2, P[2], P[1], P[0]); // camera driven light ambientMaterial(250); } for (let i = 0; i \u0026lt; positions.length; i++) { push(); translate(positions[i][0], positions[i][1], positions[i][2]); // with push and pop, translation and rotation of each box is independent of each other. rotateX(angle); rotateY(angle * 0.4); if (active) fill(colors[i]); // if zbuffer is being visualized, boxes are painted based on interpolated colors in colors array box(50); pop(); } angle += 0.01; // boxes rotation t += 1; } Update Functions, Interpolation and Distance Calculation. # Interpolation uses 250 and 750 thresholds. These are needed so that colors changed when zooming in and zooming out. Draw Code function updateZBuffer() { zbuffer = []; for (let i = 0; i \u0026lt; positions.length; i++) { zbuffer.push(distance(P, positions[i])); // distance between box and camera position P } } function updateColors() { colors = []; // thresholds (250, 750) are used so that boxes color change when zooming in and zooming out. for (let i = 0; i \u0026lt; positions.length; i++) { colors.push(interpolate(250, 750, zbuffer[i])); // interpolation returns a gray scale color. } } // linear interpolation with gray scale colors. function interpolate(low, high, mid) { let x0 = low; let y0 = 255; let x1 = high; let y1 = 0; let x = mid; let y = y0 + (x - x0) * ((y1 - y0) / (x1 - x0)); return y; } Auxiliary Functions # active flag is to toggle z-buffer visualiztion. Auxiliary Functions Code // auxiliary functions function keyPressed() { if (active) active = false; else active = true; } function randomint(min, max) { min = Math.ceil(min); max = Math.floor(max); return Math.floor(Math.random() * (max - min + 1) + min); } Texture Mapping # Press ENTER to toggle full texture.\nPress any key (different from ENTER ) to update triangle vertexes.\nImplementation Details # The texture mapping consisted on iterating over each pixel of the real image. For each of these coordinates of the form (r, c) we applied the mapping: \\[\\left(r,\\ c\\right)\\rightarrow(\\left\\lfloor\\frac{r}{w}\\right\\rfloor,\\ \\left\\lfloor\\frac{c}{w}\\right\\rfloor\\ )\\ \\] In this implementation w is 16.\nThis mapping splits all pixels in groups of 16 x 16 = 256 pixels each one. All colors of those pixels are averaged to get the texture pixel color.\nImportant details were already presented in the first exercise. Please refer to code comments for more information.\nFull Implementation Code let w = 16; // pixels width and height is 16 let mid = 8; // pixel mid length to draw lines let img; // triangle vertexes coordinates let xA = 4; let yA = 4; let xB = 10; let yB = 10; let xC = 4; let yC = 15; let full = false; // flag to toggle full texture view function setup() { createCanvas(512 + 512, 512); LG = color(10, 150, 10); // line green img = loadImage(\u0026#39;/VisualComputing/docs/contenido/images/image.png\u0026#39;); } function draw() { image(img, 512, 0, img.width * 2, img.height * 2); // image is scaled up so we are treating it as a 512 px x 512 px image fill(0); // pixels grid is painted stroke(LG); for (let i = 0; i \u0026lt; 512; i += w) { for (let j = 0; j \u0026lt; 512; j += w) { square(i, j, w); } } let COLORS = {} // colors dictionary when key is pixel coordinate for (let i = 0; i \u0026lt; 512; i++) { let i_ = i + 512; for (let j = 0; j \u0026lt; 512; j++) { let color = get(i_, j); // color is obtained from real image let key = `${Math.floor(i / 16)}-${Math.floor(j / 16)}`; // key generation is the mapping done from real image to texture image if (COLORS[key] == null) COLORS[key] = []; COLORS[key].push(color); // each value of dictionary is an array of 16 x 16 = 256 colors } } // for each array of 256 colors, we average to get pixel color. for (const key in COLORS) { let colors = COLORS[key] let R = 0; let G = 0; let B = 0; colors.forEach((c) =\u0026gt; { R += c[0]; G += c[1]; B += c[2]; }) COLORS[key] = [Math.floor(R / 16**2), Math.floor(G / 16**2), Math.floor(B / 16**2)] // COLORS values are no longer arrays but a single averaged color. } // if full texture view, we paint all pixels. if (full) { for (const key in COLORS) { fill(COLORS[key]) let x = parseInt(key.split(\u0026#39;-\u0026#39;)[0]) let y = parseInt(key.split(\u0026#39;-\u0026#39;)[1]) square(x*w, y*w, w); } } // we paint triangle sides by using Bresenham\u0026#39;s algorithm. // we don\u0026#39;t need interpolation because we already have the colors. let PIXELS = [] pixels = bresenham(xA, yA, xB, yB) for (let i = 0; i \u0026lt; pixels.length; i++) { let c = COLORS[`${pixels[i].x}-${pixels[i].y}`] fill(color(c[0], c[1], c[2])); square(pixels[i].x*w, pixels[i].y*w, w); } PIXELS = PIXELS.concat(pixels) pixels = bresenham(xB, yB, xC, yC) for (let i = 0; i \u0026lt; pixels.length; i++) { let c = COLORS[`${pixels[i].x}-${pixels[i].y}`] fill(color(c[0], c[1], c[2])); square(pixels[i].x*w, pixels[i].y*w, w); } PIXELS = PIXELS.concat(pixels) pixels = bresenham(xC, yC, xA, yA) for (let i = 0; i \u0026lt; pixels.length; i++) { let c = COLORS[`${pixels[i].x}-${pixels[i].y}`] fill(color(c[0], c[1], c[2])); square(pixels[i].x*w, pixels[i].y*w, w); } PIXELS = PIXELS.concat(pixels) // iterate vertically row by row covering the triangle let minY = Math.min(yA, yB, yC); let maxY = Math.max(yA, yB, yC); for (let row = minY; row \u0026lt;= maxY; row++) { let limits = PIXELS.filter((p) =\u0026gt; p.y == row); // sides pixels let lmp = limits.reduce((a, b) =\u0026gt; (a.x \u0026lt; b.x) ? a : b) // right most pixel let rmp = limits.reduce((a, b) =\u0026gt; (a.x \u0026gt; b.x) ? a : b) // right most pixel if (lmp == rmp) // if both equal, just one pixel in this row and no painting is needed since no inner pixels continue; let rowpixels = []; // will contain pixels to fill the row let ip = rmp.x - lmp.x - 1; // intermediate pixels // if consecutive, 0 and for loop below won\u0026#39;t run rowpixels.push(lmp) // we add first pixel in row // won\u0026#39;t run if no intermediate pixels for (let i = 1; i \u0026lt;= ip; i++) { rowpixels.push({x:lmp.x + i, y:row}) // y is fixed, but x will be incremented from x + 1 to x + ip so that limits are ignored since they are added outside the loop } rowpixels.push(rmp) // we add last pixel in row // we add it here to conserve order // we paint row pixels using COLORS dictionary for (let i = 0; i \u0026lt; rowpixels.length; i++) { fill(COLORS[`${rowpixels[i].x}-${rowpixels[i].y}`]); square(rowpixels[i].x*w, rowpixels[i].y*w, w); } } // we paint lines on both texture and real images push(); stroke(255, 255, 255); strokeWeight(2); line(xA*w + mid, yA*w + mid, xB*w + mid, yB*w + mid); line(xB*w + mid, yB*w + mid, xC*w + mid, yC*w + mid); line(xC*w + mid, yC*w + mid, xA*w + mid, yA*w + mid); line(xA*w + mid + 512, yA*w + mid, xB*w + mid + 512, yB*w + mid); line(xB*w + mid + 512, yB*w + mid, xC*w + mid + 512, yC*w + mid); line(xC*w + mid + 512, yC*w + mid, xA*w + mid + 512, yA*w + mid); pop(); } // Bresenham\u0026#39;s line algorithm implementation function bresenham(x0, y0, x1, y1) { let dx = x1 - x0 let dy = y1 - y0 let xx let xy let yx let yy let xsign = (dx \u0026gt; 0) ? 1 : -1 let ysign = (dy \u0026gt; 0) ? 1 : -1 dx = Math.abs(dx) dy = Math.abs(dy) if (dx \u0026gt; dy) { xx = xsign xy = 0 yx = 0 yy = ysign } else { temp = dx dx = dy dy = temp xx = 0 xy = ysign yx = xsign yy = 0 } let D = 2*dy - dx let y = 0 let pixels = [] for (let x = 0; x \u0026lt; dx + 1; x++) { pixels.push({x: x0 + x*xx + y*yx, y: y0 + x*xy + y*yy}) if (D \u0026gt;= 0) { y += 1 D -= 2*dx } D += 2*dy } return pixels } // Auxiliaty Functions function keyPressed() { if (keyCode === ENTER \u0026amp;\u0026amp; !full) full = true; else if (keyCode === ENTER \u0026amp;\u0026amp; full) full = false; else { xA = randomint(0, 31); yA = randomint(0, 31); xB = randomint(0, 31); yB = randomint(0, 31); xC = randomint(0, 31); yC = randomint(0, 31); } } function randomint(min, max) { min = Math.ceil(min); max = Math.floor(max); return Math.floor(Math.random() * (max - min + 1) + min); } Generalized Texture Mapping # Press ENTER to toggle full texture.\nPress any key (different from ENTER ) to update triangle vertexes.\nImplementation Details # Following is a generalized implementation of texture mapping that allows the user to upload an image.\nImplementation is the same as the one we presented, but it now uses a file handler and construct a canvas and a pixels grid based on the uploaded image dimensions.\nMapping keeps being done with w = 16 to get groups of 256 pixels.\nFor a better experience, please consider to upload small to medium size images.\nFull Implementation Code let mid = 8; let w = 16; // pixel width and height: split is in groups of 256 pixels. let input; let img; let xA = 4; let yA = 4; let xB = 10; let yB = 10; let xC = 4; let yC = 15; let full = false; let width; let height; function setup() { LG = color(150); input = createFileInput(handleFile); } function draw() { if (img != null \u0026amp;\u0026amp; img.width \u0026gt; 0) { width = img.width; height = img.height; input.position(2 * width, 0); createCanvas(2 * width, height); image(img, width, 0); fill(100); stroke(LG); for (let i = 0; i \u0026lt; width; i += w) { for (let j = 0; j \u0026lt; height; j += w) { square(i, j, w); } } let COLORS = {} for (let i = 0; i \u0026lt; width; i++) { let i_ = i + width; for (let j = 0; j \u0026lt; height; j++) { let color = get(i_, j); let key = `${Math.floor(i / w)}-${Math.floor(j / w)}`; if (COLORS[key] == null) COLORS[key] = []; COLORS[key].push(color); } } for (const key in COLORS) { let colors = COLORS[key] let R = 0; let G = 0; let B = 0; colors.forEach((c) =\u0026gt; { R += c[0]; G += c[1]; B += c[2]; }) COLORS[key] = [Math.floor(R / w**2), Math.floor(G / w**2), Math.floor(B / w**2)] } if (full) { for (const key in COLORS) { fill(COLORS[key]) let x = parseInt(key.split(\u0026#39;-\u0026#39;)[0]) let y = parseInt(key.split(\u0026#39;-\u0026#39;)[1]) square(x*w, y*w, w); } } let PIXELS = [] pixels = bresenham(xA, yA, xB, yB) for (let i = 0; i \u0026lt; pixels.length; i++) { let c = COLORS[`${pixels[i].x}-${pixels[i].y}`] if (c == null) continue fill(color(c[0], c[1], c[2])); square(pixels[i].x*w, pixels[i].y*w, w); } PIXELS = PIXELS.concat(pixels) pixels = bresenham(xB, yB, xC, yC) for (let i = 0; i \u0026lt; pixels.length; i++) { let c = COLORS[`${pixels[i].x}-${pixels[i].y}`] if (c == null) continue fill(color(c[0], c[1], c[2])); square(pixels[i].x*w, pixels[i].y*w, w); } PIXELS = PIXELS.concat(pixels) pixels = bresenham(xC, yC, xA, yA) for (let i = 0; i \u0026lt; pixels.length; i++) { let c = COLORS[`${pixels[i].x}-${pixels[i].y}`] if (c == null) continue fill(color(c[0], c[1], c[2])); square(pixels[i].x*w, pixels[i].y*w, w); } PIXELS = PIXELS.concat(pixels) // iterate vertically row by row covering the triangle let minY = Math.min(yA, yB, yC); let maxY = Math.max(yA, yB, yC); for (let row = minY; row \u0026lt;= maxY; row++) { let limits = PIXELS.filter((p) =\u0026gt; p.y == row); // sides pixels let lmp = limits.reduce((a, b) =\u0026gt; (a.x \u0026lt; b.x) ? a : b) // right most pixel let rmp = limits.reduce((a, b) =\u0026gt; (a.x \u0026gt; b.x) ? a : b) // right most pixel if (lmp == rmp) // if both equal, just one pixel in this row and no inner pixels continue; let rowpixels = []; // will contain pixels to fill the row let ip = rmp.x - lmp.x - 1; // intermediate pixels // if consecutive, 0 and for loop below won\u0026#39;t run rowpixels.push(lmp) // we add first pixel in row // won\u0026#39;t run if no intermediate pixels for (let i = 1; i \u0026lt;= ip; i++) { rowpixels.push({x:lmp.x + i, y:row}) // y is fixed, but x will be incremented from x + 1 to x + ip so that limits are ignored since they are added outside the loop } rowpixels.push(rmp) // we add last pixel in row // we add it here to conserve order for (let i = 0; i \u0026lt; rowpixels.length; i++) { let c = COLORS[`${rowpixels[i].x}-${rowpixels[i].y}`] if (c == null) continue fill(c); square(rowpixels[i].x*w, rowpixels[i].y*w, w); } } push(); stroke(255, 255, 255); strokeWeight(2); line(xA*w + mid, yA*w + mid, xB*w + mid, yB*w + mid); line(xB*w + mid, yB*w + mid, xC*w + mid, yC*w + mid); line(xC*w + mid, yC*w + mid, xA*w + mid, yA*w + mid); line(xA*w + mid + width, yA*w + mid, xB*w + mid + width, yB*w + mid); line(xB*w + mid + width, yB*w + mid, xC*w + mid + width, yC*w + mid); line(xC*w + mid + width, yC*w + mid, xA*w + mid + width, yA*w + mid); pop(); } } function keyPressed() { if (keyCode === ENTER \u0026amp;\u0026amp; !full) full = true; else if (keyCode === ENTER \u0026amp;\u0026amp; full) full = false; else { xA = randomint(0, Math.floor(width / w) - 1); yA = randomint(0, Math.floor(height / w) - 1); xB = randomint(0, Math.floor(width / w) - 1); yB = randomint(0, Math.floor(height / w) - 1); xC = randomint(0, Math.floor(width / w) - 1); yC = randomint(0, Math.floor(height / w) - 1); } } function randomint(min, max) { min = Math.ceil(min); max = Math.floor(max); return Math.floor(Math.random() * (max - min + 1) + min); } function bresenham(x0, y0, x1, y1) { let dx = x1 - x0 let dy = y1 - y0 let xx let xy let yx let yy let xsign = (dx \u0026gt; 0) ? 1 : -1 let ysign = (dy \u0026gt; 0) ? 1 : -1 dx = Math.abs(dx) dy = Math.abs(dy) if (dx \u0026gt; dy) { xx = xsign xy = 0 yx = 0 yy = ysign } else { temp = dx dx = dy dy = temp xx = 0 xy = ysign yx = xsign yy = 0 } let D = 2*dy - dx let y = 0 let pixels = [] for (let x = 0; x \u0026lt; dx + 1; x++) { pixels.push({x: x0 + x*xx + y*yx, y: y0 + x*xy + y*yy}) if (D \u0026gt;= 0) { y += 1 D -= 2*dx } D += 2*dy } return pixels } function handleFile(file) { print(file); if (file.type === \u0026#39;image\u0026#39;) { img = createImg(file.data, \u0026#39;\u0026#39;); img.hide(); } else { img = null; } } Some Examples # Anti-aliasing # Press ENTER to toggle anti-aliasing.\nPress BACKSPACE to toggle triangle lines.\nPress any other key to randomly update triangle vertexes.\nImplementation Details # Implementation is almost the same as the first exercise we presented. The difference is that it adds an additional layer for anti-aliasing.\nThe anti-aliasing was implemented based on Fabian “ryg” Giesen blog article: \u0026ldquo;The barycentric conspiracy\u0026rdquo; which is available at: The Barycentric Conspiracy by Fabian \u0026ldquo;ryg\u0026rdquo; Giesen\nSummarizing, the anti-aliasing implemented consists in: taking all pixels belonging to the triangle sides (obtained from Bresenham\u0026rsquo;s line algorithm). Subdividing each of these pixels in 4 subpixels. For each of these subpixels, apply the barycentric coordinates method to determine whether the point in the center of each of these subpixels is in the triangle. The test will either return true or false. If it\u0026rsquo;s true, then we use pixel (the pixel to whcih the subpixel belongs) color. If false, we use background color which in this case is black (0). We add the four colors and take its average. We paint all subpixels with this color.\nThe code used to test whether a point is in a triangle (describe by its vertexes A, B, C) was took from Glenn Slayden answer to the following question in Stack Overflow: How to determine if a point is in a 2D triangle? [closed]. Glenn\u0026rsquo;s answer computes the test without needing to know how are the triangle vertexes numbered: clockwise or counterclockwise, which is a requirement of other implementations.\nFull Implementation Code let mid = 16; let w = 32; // width and height of pixels let xA = 4; let yA = 4; let xB = 10; let yB = 10; let xC = 4; let yC = 15; let pixels; let colors; let antialiasing = false; let lines = true; // color pickers let cpA let cpB let cpC function setup() { createCanvas(640, 640); R = color(220, 10, 10); // red cpA = createColorPicker(R); cpA.position(0, height + 5); G = color(10, 220, 10); // green cpB = createColorPicker(G); cpB.position(50, height + 5); B = color(10, 10, 220); // blue cpC = createColorPicker(B); cpC.position(100, height + 5); LG = color(10, 150, 10); // line green } function draw() { // colors will be set based on color pickers R = cpA.color() G = cpB.color() B = cpC.color() fill(0); stroke(LG); for (let i = 0; i \u0026lt; 640; i += w) { for (let j = 0; j \u0026lt; 640; j += w) { square(i, j, w); } } fill(R); square(xA*w, yA*w, w); fill(G); square(xB*w, yB*w, w); fill(B); square(xC*w, yC*w, w); let PIXELS = [] let COLORS = {} pixels = bresenham(xA, yA, xB, yB) colors = interpolate(R, G, pixels.length) for (let i = 0; i \u0026lt; pixels.length; i++) { COLORS[`[${pixels[i].x}-${pixels[i].y}]`] = colors[i] fill(colors[i]); square(pixels[i].x*w, pixels[i].y*w, w); } PIXELS = PIXELS.concat(pixels) pixels = bresenham(xB, yB, xC, yC) colors = interpolate(G, B, pixels.length) for (let i = 0; i \u0026lt; pixels.length; i++) { COLORS[`[${pixels[i].x}-${pixels[i].y}]`] = colors[i] fill(colors[i]); square(pixels[i].x*w, pixels[i].y*w, w); } PIXELS = PIXELS.concat(pixels) pixels = bresenham(xC, yC, xA, yA) colors = interpolate(B, R, pixels.length) for (let i = 0; i \u0026lt; pixels.length; i++) { COLORS[`[${pixels[i].x}-${pixels[i].y}]`] = colors[i] fill(colors[i]); square(pixels[i].x*w, pixels[i].y*w, w); } PIXELS = PIXELS.concat(pixels) // iterate vertically row by row covering the triangle let minY = Math.min(yA, yB, yC); let maxY = Math.max(yA, yB, yC); for (let row = minY; row \u0026lt;= maxY; row++) { let limits = PIXELS.filter((p) =\u0026gt; p.y == row); // sides pixels let lmp = limits.reduce((a, b) =\u0026gt; (a.x \u0026lt; b.x) ? a : b) // right most pixel let rmp = limits.reduce((a, b) =\u0026gt; (a.x \u0026gt; b.x) ? a : b) // right most pixel if (lmp == rmp) // if both equal, no inner pixels continue; let rowpixels = []; // will contain pixels to fill the row let ip = rmp.x - lmp.x - 1; // intermediate pixels // if consecutive, 0 and for loop below won\u0026#39;t run rowpixels.push(lmp) // we add first pixel in row // won\u0026#39;t run if no intermediate pixels for (let i = 1; i \u0026lt;= ip; i++) { rowpixels.push({x:lmp.x + i, y:row}) // y is fixed, but x will be incremented from x + 1 to x + ip so that limits are ignored since they are added outside the loop } rowpixels.push(rmp) // we add last pixel in row // we add it here to conserve order // COLORS dict lookup to get colors and start interpolation let lmc = COLORS[`[${lmp.x}-${lmp.y}]`] // left most color let rmc = COLORS[`[${rmp.x}-${rmp.y}]`] // right most color colors = interpolate(lmc, rmc, rowpixels.length) for (let i = 0; i \u0026lt; rowpixels.length; i++) { fill(colors[i]); square(rowpixels[i].x*w, rowpixels[i].y*w, w); } } // ANTI-ALIASING if (antialiasing) { // Vertexes pixels center points let tA = { x:xA*w + w/2, y:yA*w + w/2 }; let tB = { x:xB*w + w/2, y:yB*w + w/2 }; let tC = { x:xC*w + w/2, y:yC*w + w/2 }; // SIDES PIXELS ARE DIVIDED IN 4 SUBPIXELS for (let i = 0; i \u0026lt; PIXELS.length; i++) { let x = PIXELS[i].x; let y = PIXELS[i].y; let c = COLORS[`[${x}-${y}]`]; let SUBPIXELS = [ { x: x*w, y:y*w }, { x: x*w + w/2, y: y*w }, { x: x*w, y: y*w + w/2 }, { x: x*w + w/2, y: y*w + w/2 } ] let R = 0; let G = 0; let B = 0; // FOR EACH SUBPIXEL WE DETERMINE IF ITS CENTER IS IN THE TRIANGLE // IF YES: WE USE PIXEL COLOR // IF NOT: WE USE BLACK COLOR (BACKGROUND COLOR: 0, WE ADD NOTHING TO THE AVERAGE SUM) // WE AVERAGE COLORS TO PAINT THE WHOLE PIXEL SUBPIXELS.forEach((SP) =\u0026gt; { let P = { x: SP.x + w/4, y: SP.y + w/4 }; // center of sub pixel let covered = PInTriangle(P, tA, tB, tC); if (covered) { // if not covered we don\u0026#39;t add (add 0 which is like adding black (background color)) R += c._getRed(); G += c._getGreen(); B += c._getBlue(); } }) R = R / 4; G = G / 4; B = B / 4; fill(color(R, G, B)); // WE PAINT ALL SUBPIXELS WITH THE SAME AVERAGED COLOR SUBPIXELS.forEach((SP) =\u0026gt; { square(SP.x, SP.y, w/2); }) } } if (lines) { // we now paint the triangle lines using mid so that line starts and ends in the center of a pixel push(); stroke(10, 200, 200); strokeWeight(5); line(xA*w + mid, yA*w + mid, xB*w + mid, yB*w + mid); line(xB*w + mid, yB*w + mid, xC*w + mid, yC*w + mid); line(xC*w + mid, yC*w + mid, xA*w + mid, yA*w + mid); pop(); } } // piece of code took from Glenn Slayden answer to the following StackOverflow question: https://stackoverflow.com/questions/2049582/how-to-determine-if-a-point-is-in-a-2d-triangle // This function applies barycentric coordinates method but doesn\u0026#39;t need to know if vertex are numerated clock or counter-clock wise. function PInTriangle(P, A, B, C) { let s = (A.x - C.x) * (P.y - C.y) - (A.y - C.y) * (P.x - C.x); let t = (B.x - A.x) * (P.y - A.y) - (B.y - A.y) * (P.x - A.x); if ((s \u0026lt; 0) != (t \u0026lt; 0) \u0026amp;\u0026amp; s != 0 \u0026amp;\u0026amp; t != 0) return false; var d = (C.x - B.x) * (P.y - B.y) - (C.y - B.y) * (P.x - B.x); return d == 0 || (d \u0026lt; 0) == (s + t \u0026lt;= 0); } // Bresenham\u0026#39;s line algorithm to draw sides. function bresenham(x0, y0, x1, y1) { let dx = x1 - x0 let dy = y1 - y0 let xx let xy let yx let yy let xsign = (dx \u0026gt; 0) ? 1 : -1 let ysign = (dy \u0026gt; 0) ? 1 : -1 dx = Math.abs(dx) dy = Math.abs(dy) if (dx \u0026gt; dy) { xx = xsign xy = 0 yx = 0 yy = ysign } else { temp = dx dx = dy dy = temp xx = 0 xy = ysign yx = xsign yy = 0 } let D = 2*dy - dx let y = 0 let pixels = [] for (let x = 0; x \u0026lt; dx + 1; x++) { pixels.push({x: x0 + x*xx + y*yx, y: y0 + x*xy + y*yy}) if (D \u0026gt;= 0) { y += 1 D -= 2*dx } D += 2*dy } return pixels } // Interpolation for shading coloring function interpolate(c0, c1, n) { let colors = [] let r0 = c0._getRed() // color 0 red let g0 = c0._getGreen() // color 0 green let b0 = c0._getBlue() // color 0 blue let r1 = c1._getRed() // color 1 red let g1 = c1._getGreen() // color 1 green let b1 = c1._getBlue() // color 1 blue for (let i = 0; i \u0026lt; n; i++) { d = n - 1; // denominator n0 = d - i; // color 0 numerator n1 = i; // color 1 numerator ratio_0 = n0 / d; ratio_1 = n1 / d; scaled_r0 = ratio_0 * r0; // scaled red 0 scaled_g0 = ratio_0 * g0; // scaled green 0 scaled_b0 = ratio_0 * b0; // scaled blue 0 scaled_r1 = ratio_1 * r1; // scaled red 0 scaled_g1 = ratio_1 * g1; // scaled green 0 scaled_b1 = ratio_1 * b1; // scaled blue 0 interpolated_r = scaled_r0 + scaled_r1; interpolated_g = scaled_g0 + scaled_g1; interpolated_b = scaled_b0 + scaled_b1; colors.push(color(interpolated_r, interpolated_g, interpolated_b)); } return colors } // Auxiliary Functions function keyPressed() { if (keyCode == ENTER \u0026amp;\u0026amp; antialiasing == false) { antialiasing = true; } else if (keyCode == ENTER \u0026amp;\u0026amp; antialiasing == true) { antialiasing = false; } else if (keyCode == BACKSPACE \u0026amp;\u0026amp; lines == false) { lines = true } else if (keyCode == BACKSPACE \u0026amp;\u0026amp; lines == true) { lines = false } else { xA = randomint(0, 19); yA = randomint(0, 19); xB = randomint(0, 19); yB = randomint(0, 19); xC = randomint(0, 19); yC = randomint(0, 19); } } function randomint(min, max) { min = Math.ceil(min); max = Math.floor(max); return Math.floor(Math.random() * (max - min + 1) + min); // The maximum is inclusive and the minimum is inclusive } "},{"id":5,"href":"/VisualComputing/docs/shaders/texturing/","title":"Texturing","section":"Shaders","content":" Exercise # Implement other coloring brightness tools such as HSV value V, HSL lightness L or Component average. Implement texture tinting by mixing color and texel interpolated data. Brightness \u0026amp; Tinting # El ejercicio se compone de dos partes: La primera consiste en la visualización de la iluminación de la imagen y la segunda es la aplicación de tinting sobre la imagen utilizando diferentes blending modes.\nLa iluminación se implementó con un brightness shader usando las siguientes cuatro métricas: luma, value (HSV), lightness (HSL) e intensidad (HSI).\nPara cada texel se calcula la métrica indicada y ese valor (normalizado [0..1]) se aplica sobre un vector vec4 en el shader para pintar cada pixel, de manera que la visualización es en escala de grises.\nPara el tinting, desde el sketch, se dibuja un rectángulo sobre la imagen cargada. Cada uno de los cuatro vertices tiene un color asociado que puede ser seleccionado por el usuario. Estos valores le sirven al vertex shader para hacer la interpolación de los colores de los pixeles de todo el rectángulo.\nEl tinting shader recibe interpoladas las coordernadas de la imagen cargada (texcoords2) y el color (color4) interpolado desde el vertex shader. Con esas dos variables, el tinting shader aplica el blending mode seleccionado. El color A es el color del texel cuyas coordenadas son texcoords2 y el color B es el color que llegó interpolado desde el vertex shader.\nAl aplicar la operación texel a texel, el color resultante se va pintando, y la imagen queda tinturada con el blending mode aplicado.\nLos blending modes aplicados son los mismos vistos en Coloring.\nControles # Botón Choose File: para cargar una imagen o video Checkbox Default Video: marcar para usar el video por defecto, desmarcar para usar la imagen por defecto Select: selecciona entre original, luma, value, lightness, intensity o tinting Select (Blending Mode): selecciona el blending mode que desea utilizar (visible cuando se selecciona tinting) Slider: controla el brillo (visible cuando se selecciona tinting) Color Pickers: para seleccionar los colores que se aplicarán en el tinting Sketch Code let brightnessShader; let tintingShader; let img; let input; let mode; let lmselect; // lightness mode select let colorA; let colorB; let colorC; let colorD; let cpcikerA; let cpcikerB; let cpcikerC; let cpcikerD; let bmselect; // blending mode select let bmode; let bslider; // brightness slider let video_on; function preload() { brightnessShader = readShader(\u0026#39;/VisualComputing/docs/shaders/fragments/brightness.frag\u0026#39;, { varyings: Tree.texcoords2 }); tintingShader = readShader(\u0026#39;/VisualComputing/docs/shaders/fragments/tinting.frag\u0026#39;, { varyings: [Tree.texcoords2 | Tree.color4] }); } function setup() { createCanvas(700, 500, WEBGL); noStroke(); textureMode(NORMAL); lmselect = createSelect(); lmselect.position(10, 10); lmselect.option(\u0026#39;original\u0026#39;, 0); lmselect.option(\u0026#39;luma\u0026#39;, 1); lmselect.option(\u0026#39;value\u0026#39;, 2); lmselect.option(\u0026#39;lightness\u0026#39;, 3); lmselect.option(\u0026#39;intensity\u0026#39;, 4); lmselect.option(\u0026#39;tinting\u0026#39;, 5); lmselect.selected(\u0026#39;original\u0026#39;); img = loadImage(\u0026#39;/VisualComputing/docs/shaders/resources/fire_breathing.png\u0026#39;); input = createFileInput(handleFile); colorA = \u0026#34;red\u0026#34;; colorB = \u0026#34;green\u0026#34;; colorC = \u0026#34;blue\u0026#34;; colorD = \u0026#34;yellow\u0026#34;; cpickerA = createColorPicker(colorA); cpickerA.position(20, 40); cpickerA.hide(); cpickerB = createColorPicker(colorB); cpickerB.position(640, 40); cpickerB.hide(); cpickerC = createColorPicker(colorC); cpickerC.position(20, 440); cpickerC.hide(); cpickerD = createColorPicker(colorD); cpickerD.position(640, 440); cpickerD.hide(); bslider = createSlider(0, 1, 1, 0.05); bslider.position(280, 10); bslider.style(\u0026#39;width\u0026#39;, \u0026#39;80px\u0026#39;); bslider.hide(); bmselect = createSelect(); bmselect.position(100, 10); bmselect.option(\u0026#39;MULTIPLY\u0026#39;, 0); bmselect.option(\u0026#39;ADD (LINEAR DODGE)\u0026#39;, 1); bmselect.option(\u0026#39;SCREEN\u0026#39;, 2); bmselect.option(\u0026#39;OVERLAY\u0026#39;, 3); bmselect.option(\u0026#39;DARKEST\u0026#39;, 4); bmselect.option(\u0026#39;LIGHTEST\u0026#39;, 5); bmselect.option(\u0026#39;COLOR BURN\u0026#39;, 6); bmselect.option(\u0026#39;LINEAR BURN\u0026#39;, 7); bmselect.option(\u0026#39;DIFFERENCE\u0026#39;, 8); bmselect.option(\u0026#39;DIVIDE\u0026#39;, 9); bmselect.option(\u0026#39;EXCLUSION\u0026#39;, 10); bmselect.option(\u0026#39;COLOR DODGE\u0026#39;, 11); bmselect.option(\u0026#39;HARD LIGHT\u0026#39;, 12); bmselect.option(\u0026#39;VIVID LIGHT\u0026#39;, 13); bmselect.option(\u0026#39;LINEAR LIGHT\u0026#39;, 14); bmselect.option(\u0026#39;PIN LIGHT\u0026#39;, 15); bmselect.option(\u0026#39;SOFT LIGHT 1\u0026#39;, 16); // photoshop bmselect.option(\u0026#39;SOFT LIGHT 2\u0026#39;, 17); // pegtop bmselect.option(\u0026#39;SOFT LIGHT 3\u0026#39;, 18); // ilussions.hu bmselect.option(\u0026#39;SOFT LIGHT 4\u0026#39;, 19); // w3C bmselect.selected(\u0026#39;MULTIPLY\u0026#39;); bmselect.hide(); video_on = createCheckbox(\u0026#39;default video\u0026#39;, false); video_on.changed(() =\u0026gt; { if (video_on.checked()) { img = createVideo([\u0026#39;/VisualComputing/docs/shaders/resources/video0.mp4\u0026#39;]); img.hide(); img.loop(); } else { img = loadImage(\u0026#39;/VisualComputing/docs/shaders/resources/fire_breathing.png\u0026#39;); img.hide(); img.pause(); } blendShader.setUniform(\u0026#39;texture\u0026#39;, img); tintingShader.setUniform(\u0026#39;texture\u0026#39;, img); }) } function draw() { background(0); image(img, 0, 0, 700, 500); mode = lmselect.value() if (mode == 5) { cpickerA.show(); colorA = cpickerA.color() cpickerB.show(); colorB = cpickerB.color() cpickerC.show(); colorC = cpickerC.color() cpickerD.show(); colorD = cpickerD.color() bmselect.show(); bmode = bmselect.value(); bslider.show(); brightness = bslider.value(); shader(tintingShader); beginShape(); fill(colorA); vertex(-width / 2, -height / 2); fill(colorB); vertex(width / 2, -height / 2); fill(colorC); vertex(width / 2, height / 2); fill(colorD); vertex(-width / 2, height / 2); endShape(); tintingShader.setUniform(\u0026#39;brightness\u0026#39;, brightness); tintingShader.setUniform(\u0026#39;mode\u0026#39;, bmode); tintingShader.setUniform(\u0026#39;texture\u0026#39;, img); } else { cpickerA.hide(); cpickerB.hide(); cpickerC.hide(); cpickerD.hide(); bmselect.hide(); bslider.hide(); shader(brightnessShader); brightnessShader.setUniform(\u0026#39;texture\u0026#39;, img); brightnessShader.setUniform(\u0026#39;mode\u0026#39;, mode); } quad(-width / 2, -height / 2, width / 2, -height / 2, width / 2, height / 2, -width / 2, height / 2); } function handleFile(file) { if (file.type === \u0026#39;image\u0026#39;) { img = createImg(file.data, \u0026#39;\u0026#39;); img.hide(); } else if (file.type === \u0026#39;video\u0026#39;) { img = createVideo([file.data]); img.hide(); img.loop(); } } function randomint(min, max) { min = Math.ceil(min); max = Math.floor(max); return Math.floor(Math.random() * (max - min + 1) + min); } Brightness Shader precision mediump float; uniform int mode; uniform sampler2D texture; varying vec2 texcoords2; float luma(vec3 texel) { return 0.299 * texel.r + 0.587 * texel.g + 0.114 * texel.b; } float value(vec3 texel) { return max(texel.r, max(texel.g, texel.b)); } float lightness(vec3 texel) { float M = max(texel.r, max(texel.g, texel.b)); float m = min(texel.r, min(texel.g, texel.b)); return 0.5 * (M + m); } float intensity(vec3 texel) { return (1. / 3.) * (texel.r + texel.g + texel.b); } void main() { vec4 texel = texture2D(texture, texcoords2); if (mode == 1) { gl_FragColor = vec4((vec3(luma(texel.rgb))), 1.0); } else if (mode == 2) { gl_FragColor = vec4((vec3(value(texel.rgb))), 1.0); } else if (mode == 3) { gl_FragColor = vec4((vec3(lightness(texel.rgb))), 1.0); } else if (mode == 4) { gl_FragColor = vec4((vec3(intensity(texel.rgb))), 1.0); } else { gl_FragColor = texel; } } Tinting Shader precision mediump float; uniform sampler2D texture; uniform int mode; uniform float brightness; varying vec2 texcoords2; varying vec4 color4; void main() { vec4 texel = texture2D(texture, texcoords2); vec4 colorA = texel; vec4 colorB = color4; if (mode == 0) { // multiply gl_FragColor = colorA * colorB * brightness; } else if (mode == 1) { // add (linear dodge) gl_FragColor = (colorA + colorB) * brightness; } else if (mode == 2) { // screen gl_FragColor = (1. - (1. - colorA) * (1. - colorB)) * brightness; } else if (mode == 3) { // overlay float R = (colorA[0] \u0026lt; 0.5) ? 2. * colorA[0] * colorB[0] : (1. - (1. - colorA[0]) * (1. - colorB[0])); float G = (colorA[1] \u0026lt; 0.5) ? 2. * colorA[1] * colorB[1] : (1. - (1. - colorA[1]) * (1. - colorB[1])); float B = (colorA[2] \u0026lt; 0.5) ? 2. * colorA[2] * colorB[2] : (1. - (1. - colorA[2]) * (1. - colorB[2])); float A = (colorA[3] \u0026lt; 0.5) ? 2. * colorA[3] * colorB[3] : (1. - (1. - colorA[3]) * (1. - colorB[3])); gl_FragColor = vec4(R, G, B, A) * brightness; } else if (mode == 4) { // darkest gl_FragColor = vec4(min(colorA[0], colorB[0]), min(colorA[1], colorB[1]), min(colorA[2], colorB[2]), min(colorA[3], colorB[3])) * brightness; } else if (mode == 5) { // lightest gl_FragColor = vec4(max(colorA[0], colorB[0]), max(colorA[1], colorB[1]), max(colorA[2], colorB[2]), max(colorA[3], colorB[3])) * brightness; } else if (mode == 6) { // color burn gl_FragColor = 1. - ((1. - colorA) / colorB) * brightness; } else if (mode == 7) { // linear burn gl_FragColor = (colorA + colorB - 1.) * brightness; } else if (mode == 8) { // difference gl_FragColor = (abs(colorA - colorB)) * brightness; } else if (mode == 9) { // divide gl_FragColor = (colorA / colorB) * brightness; } else if (mode == 10) { // exclusion gl_FragColor = (0.5 - 2. * (colorA - 0.5) * (colorB - 0.5)) * brightness; } else if (mode == 11) { // color dodge gl_FragColor = (colorA / (1. - colorB)) * brightness; } else if (mode == 12) { // hard light float R = (colorB[0] \u0026gt; 0.5) ? (1. - (1. - colorA[0]) * (1. - 2. * (colorB[0] - 0.5))) : colorA[0] * 2. * colorB[0]; float G = (colorB[1] \u0026gt; 0.5) ? (1. - (1. - colorA[1]) * (1. - 2. * (colorB[1] - 0.5))) : colorA[1] * 2. * colorB[1]; float B = (colorB[2] \u0026gt; 0.5) ? (1. - (1. - colorA[2]) * (1. - 2. * (colorB[2] - 0.5))) : colorA[2] * 2. * colorB[2]; float A = (colorB[3] \u0026gt; 0.5) ? (1. - (1. - colorA[3]) * (1. - 2. * (colorB[3] - 0.5))) : colorA[3] * 2. * colorB[3]; gl_FragColor = vec4(R, G, B, A) * brightness; } else if (mode == 13) { // vivid light float R = (colorB[0] \u0026gt; 0.5) ? colorA[0] / (1. - 2. * (colorB[0] - 0.5)) : (1. - (1. - colorA[0]) / (2. * colorB[0])); float G = (colorB[1] \u0026gt; 0.5) ? colorA[1] / (1. - 2. * (colorB[1] - 0.5)) : (1. - (1. - colorA[1]) / (2. * colorB[1])); float B = (colorB[2] \u0026gt; 0.5) ? colorA[2] / (1. - 2. * (colorB[2] - 0.5)) : (1. - (1. - colorA[2]) / (2. * colorB[2])); float A = (colorB[3] \u0026gt; 0.5) ? colorA[3] / (1. - 2. * (colorB[3] - 0.5)) : (1. - (1. - colorA[3]) / (2. * colorB[3])); gl_FragColor = vec4(R, G, B, A) * brightness; } else if (mode == 14) { // vivid light float R = (colorB[0] \u0026gt; 0.5) ? colorA[0] + 2. * (colorB[0] - 0.5) : (colorA[0] + 2. * colorB[0] - 1.); float G = (colorB[1] \u0026gt; 0.5) ? colorA[1] + 2. * (colorB[1] - 0.5) : (colorA[1] + 2. * colorB[1] - 1.); float B = (colorB[2] \u0026gt; 0.5) ? colorA[2] + 2. * (colorB[2] - 0.5) : (colorA[2] + 2. * colorB[2] - 1.); float A = (colorB[3] \u0026gt; 0.5) ? colorA[3] + 2. * (colorB[3] - 0.5) : (colorA[3] + 2. * colorB[3] - 1.); gl_FragColor = vec4(R, G, B, A) * brightness; } else if (mode == 15) { // pin light float R = (colorB[0] \u0026gt; 0.5) ? max(colorA[0], 2. * (colorB[0] - 0.5)) : min(colorA[0], 2. * colorB[0]); float G = (colorB[1] \u0026gt; 0.5) ? max(colorA[1], 2. * (colorB[1] - 0.5)) : min(colorA[1], 2. * colorB[1]); float B = (colorB[2] \u0026gt; 0.5) ? max(colorA[2], 2. * (colorB[2] - 0.5)) : min(colorA[2], 2. * colorB[2]); float A = (colorB[3] \u0026gt; 0.5) ? max(colorA[3], 2. * (colorB[3] - 0.5)) : min(colorA[3], 2. * colorB[3]); gl_FragColor = vec4(R, G, B, A) * brightness; } else if (mode == 16) { // soft light photoshop float R = (colorB[0] \u0026lt; 0.5) ? 2. * colorA[0] * colorB[0] + colorA[0] * colorA[0] * (1. - 2. * colorB[0]) : 2. * colorA[0] * (1. - colorB[0]) + sqrt(colorA[0]) * (2. * colorB[0] - 1.); float G = (colorB[1] \u0026lt; 0.5) ? 2. * colorA[1] * colorB[1] + colorA[1] * colorA[1] * (1. - 2. * colorB[1]) : 2. * colorA[1] * (1. - colorB[1]) + sqrt(colorA[1]) * (2. * colorB[1] - 1.); float B = (colorB[2] \u0026lt; 0.5) ? 2. * colorA[2] * colorB[2] + colorA[2] * colorA[2] * (1. - 2. * colorB[2]) : 2. * colorA[2] * (1. - colorB[2]) + sqrt(colorA[2]) * (2. * colorB[2] - 1.); float A = (colorB[3] \u0026lt; 0.5) ? 2. * colorA[3] * colorB[3] + colorA[3] * colorA[3] * (1. - 2. * colorB[3]) : 2. * colorA[3] * (1. - colorB[3]) + sqrt(colorA[3]) * (2. * colorB[3] - 1.); gl_FragColor = vec4(R, G, B, A) * brightness; } else if (mode == 17) { // soft light pegtop gl_FragColor = ((1. - (2. * colorB)) * (colorA * colorA) + (2. * colorB * colorA)) * brightness; } else if (mode == 18) { // soft light illusions.hu float R = pow(colorA[0], pow(2., 2. * (0.5 - colorB[0]))); float G = pow(colorA[1], pow(2., 2. * (0.5 - colorB[1]))); float B = pow(colorA[2], pow(2., 2. * (0.5 - colorB[2]))); float A = pow(colorA[3], pow(2., 2. * (0.5 - colorB[3]))); gl_FragColor = vec4(R, G, B, A) * brightness; } else if (mode == 19) { // soft-light w3c float gRa = (colorA[0] \u0026lt;= 0.25) ? ((16. * colorA[0] - 12.) * colorA[0] + 4.) * colorA[0] : sqrt(colorA[0]); float gGa = (colorA[1] \u0026lt;= 0.25) ? ((16. * colorA[1] - 12.) * colorA[1] + 4.) * colorA[1] : sqrt(colorA[1]); float gBa = (colorA[2] \u0026lt;= 0.25) ? ((16. * colorA[2] - 12.) * colorA[2] + 4.) * colorA[2] : sqrt(colorA[2]); float gAa = (colorA[3] \u0026lt;= 0.25) ? ((16. * colorA[3] - 12.) * colorA[3] + 4.) * colorA[3] : sqrt(colorA[3]); float R = (colorB[0] \u0026lt;= 0.5) ? colorA[0] - (1. - 2. * colorB[0]) * colorA[0] * (1. - colorA[0]) : colorA[0] + (2. * colorB[0] - 1.) * (gRa - colorA[0]); float G = (colorB[1] \u0026lt;= 0.5) ? colorA[1] - (1. - 2. * colorB[1]) * colorA[1] * (1. - colorA[1]) : colorA[1] + (2. * colorB[1] - 1.) * (gGa - colorA[1]); float B = (colorB[2] \u0026lt;= 0.5) ? colorA[2] - (1. - 2. * colorB[2]) * colorA[2] * (1. - colorA[2]) : colorA[2] + (2. * colorB[2] - 1.) * (gBa - colorA[2]); float A = (colorB[3] \u0026lt;= 0.5) ? colorA[3] - (1. - 2. * colorB[3]) * colorA[3] * (1. - colorA[3]) : colorA[3] + (2. * colorB[3] - 1.) * (gAa - colorA[3]); gl_FragColor = vec4(R, G, B, A) * brightness; } } "},{"id":6,"href":"/VisualComputing/docs/shaders/ImageProcessing/","title":"Image Processing","section":"Shaders","content":" Exercise # Implement an image / video processing app supporting different masks, including other kernel sizes different than 3x3, and:\nA region-of-interest base tool to selectively apply a given mask.Hint: circular regions around the mouse pointer are handy and quite simple to implement by means of glsl distance. A magnifier tool. Requires a bit of research. For instance, look for it in shadertoy. Integrate luma and other coloring brightness tools. Image Processing # En esta aplicación se utilizan cuatro shaders. Uno para el masking, otro para el magnifier y el de iluminación y tinturado ya vistos en Texturing.\nEl masking se implementó para matrices 3x3 y 5x5.\nEl shader recibe cada texel y para cada uno de ellos obtiene el color y el de sus vecinos. Los vecinos dependen de si la convolución es 3x3 o 5x5. Se realiza la suma ponderada y se aplica el resultado como color del texel.\nEn esta implementación, para la convolución 3x3 se requieren al menos 9 declaraciones para calcular las coordenadas y los colores de los vecinos, mientras que para la convolución 5x5 se requieren al menos 25 declaraciones. Por esta razón se omitieron convoluciones mayores (7x7, 9x9, etc.).\nLa región de interés también es implementada en el shader de las convoluciones. Se utiliza el valor de un radio definido por el usuario, y se aplica la convolución solo a los texeles dentro del alcance de ese radio. Cuando no se selecciona región de interés se sigue usando un radio, pero muy grande de manera que el usuario vea la convolución aplicada a toda la imagen.\nEl usuario tiene la posibilidad de ingresar los valores de una matriz de convolución 3x3 o 5x5 que conozca, utilizando una lista de inputs que se habilitan cuando selecciona la máscara: user defined.\nLa implementación del magnifier fue tomada de magnifier (Shadertoy). El código se modificó parcialmente para que fuera compatible con GLSL, por ejemplo, eliminando los parámetros out, in. Cambiando el nombre de las variables FragCoord y FragColor a gl_FragCoord y gl_FragColor. Y agregando las declaraciones u_mouse y u_resolution. La variable iChannel se cambió a texture. El radio y la profundidad fueron hechos parámetros controlados desde el sketch.\nLas funcionalidades de brightness y tinting son implementadas usando los shaders ya vistos en Texturing.\nControles # Botón Choose File: para cargar una imagen o video Checkbox Default Video: marcar para usar el video por defecto, desmarcar para usar la imagen por defecto Select 3x3, 5x5: para indicar el tamaño de la convolución Select (Mask): selecciona el kernel o máscara de convolución Select (función): Seleccion masks (para ver convolución en toda la imagen), region of interest (para ver la convolución en la región de interés definida), magnifier, brightness y tinting. Slider (radio región de interés): para cambiar el radio de la región de interés Slider (radio magnifier): para cambiar el radio del magnifier Slider (profundidad magnifier): para cambiar la profundidad del magnifier Select (brightness): para seleccionar el modo de iluminación: luma, value, lightness, intensity Slider (brightness): controla el brillo (visible cuando se selecciona tinting) Color Pickers: para seleccionar los colores que se aplicarán en el tinting Inputs (user defined convolution): lista de inputs numéricos para que el usuario ingrese matriz de convolución. Sketch Code let maskShader; let magnifierShader; let brightnessShader; let tintingShader; let img; let input; let kselect; // kernel select let mask3; let mask5; let r0c0; let r0c1; let r0c2; let r0c3; let r0c4; let r1c0; let r1c1; let r1c2; let r1c3; let r1c4; let r2c0; let r2c1; let r2c2; let r2c3; let r2c4; let r3c0; let r3c1; let r3c2; let r3c3; let r3c4; let r4c0; let r4c1; let r4c2; let r4c3; let r4c4; let cells3; let cells5; let ksselect; // kernel size select let ksize; // kernel size let roiradius; // region-of-interest radius let mradius; // magnifier radius let rslider; // radius slider let dslider; // depth slider let modeselect; let mode; let lmselect; // lightning mode select let colorA; let colorB; let colorC; let colorD; let cpcikerA; let cpcikerB; let cpcikerC; let cpcikerD; let bmselect; // blending mode select let bmode; let bslider; let video_on; function preload() { maskShader = readShader(\u0026#39;/VisualComputing/docs/shaders/fragments/mask.frag\u0026#39;, { varyings: Tree.texcoords2 }); magnifierShader = readShader(\u0026#39;/VisualComputing/docs/shaders/fragments/magnifier.frag\u0026#39;, { varyings: Tree.texcoords2 }); brightnessShader = readShader(\u0026#39;/VisualComputing/docs/shaders/fragments/brightness.frag\u0026#39;, { varyings: Tree.texcoords2 }); tintingShader = readShader(\u0026#39;/VisualComputing/docs/shaders/fragments/tinting.frag\u0026#39;, { varyings: [Tree.texcoords2 | Tree.color4] }); } function setup() { createCanvas(700, 500, WEBGL); noStroke(); textureMode(NORMAL); ksselect = createSelect(); ksselect.position(20, 10); ksselect.option(\u0026#39;3x3\u0026#39;, 3); ksselect.option(\u0026#39;5x5\u0026#39;, 5); ksselect.selected(\u0026#39;3x3\u0026#39;); kselect = createSelect(); kselect.position(100, 10); kselect.option(\u0026#39;identity\u0026#39;, 0); kselect.option(\u0026#39;ridges\u0026#39;, 1); kselect.option(\u0026#39;sharpen\u0026#39;, 2); kselect.option(\u0026#39;blur\u0026#39;, 3); kselect.option(\u0026#39;top sobel\u0026#39;, 4); kselect.option(\u0026#39;right sobel\u0026#39;, 5); kselect.option(\u0026#39;bottom sobel\u0026#39;, 6); kselect.option(\u0026#39;left sobel\u0026#39;, 7); kselect.option(\u0026#39;emboss\u0026#39;, 8); kselect.option(\u0026#39;user defined\u0026#39;, 9); kselect.selected(\u0026#39;identity\u0026#39;); img = loadImage(\u0026#39;/VisualComputing/docs/shaders/resources/download.png\u0026#39;); input = createFileInput(handleFile); r0c0 = createInput(\u0026#39;\u0026#39;, \u0026#39;number\u0026#39;); r0c1 = createInput(\u0026#39;\u0026#39;, \u0026#39;number\u0026#39;); r0c2 = createInput(\u0026#39;\u0026#39;, \u0026#39;number\u0026#39;); r0c3 = createInput(\u0026#39;\u0026#39;, \u0026#39;number\u0026#39;); r0c4 = createInput(\u0026#39;\u0026#39;, \u0026#39;number\u0026#39;); r1c0 = createInput(\u0026#39;\u0026#39;, \u0026#39;number\u0026#39;); r1c1 = createInput(\u0026#39;\u0026#39;, \u0026#39;number\u0026#39;); r1c2 = createInput(\u0026#39;\u0026#39;, \u0026#39;number\u0026#39;); r1c3 = createInput(\u0026#39;\u0026#39;, \u0026#39;number\u0026#39;); r1c4 = createInput(\u0026#39;\u0026#39;, \u0026#39;number\u0026#39;); r2c0 = createInput(\u0026#39;\u0026#39;, \u0026#39;number\u0026#39;); r2c1 = createInput(\u0026#39;\u0026#39;, \u0026#39;number\u0026#39;); r2c2 = createInput(\u0026#39;\u0026#39;, \u0026#39;number\u0026#39;); r2c3 = createInput(\u0026#39;\u0026#39;, \u0026#39;number\u0026#39;); r2c4 = createInput(\u0026#39;\u0026#39;, \u0026#39;number\u0026#39;); r3c0 = createInput(\u0026#39;\u0026#39;, \u0026#39;number\u0026#39;); r3c1 = createInput(\u0026#39;\u0026#39;, \u0026#39;number\u0026#39;); r3c2 = createInput(\u0026#39;\u0026#39;, \u0026#39;number\u0026#39;); r3c3 = createInput(\u0026#39;\u0026#39;, \u0026#39;number\u0026#39;); r3c4 = createInput(\u0026#39;\u0026#39;, \u0026#39;number\u0026#39;); r4c0 = createInput(\u0026#39;\u0026#39;, \u0026#39;number\u0026#39;); r4c1 = createInput(\u0026#39;\u0026#39;, \u0026#39;number\u0026#39;); r4c2 = createInput(\u0026#39;\u0026#39;, \u0026#39;number\u0026#39;); r4c3 = createInput(\u0026#39;\u0026#39;, \u0026#39;number\u0026#39;); r4c4 = createInput(\u0026#39;\u0026#39;, \u0026#39;number\u0026#39;); cells3 = [r0c0, r0c1, r0c2, r1c0, r1c1, r1c2, r2c0, r2c1, r2c2]; cells5 = [r0c0, r0c1, r0c2, r0c3, r0c4, r1c0, r1c1, r1c2, r1c3, r1c4, r2c0, r2c1, r2c2, r2c3, r2c4, r3c0, r3c1, r3c2, r3c3, r3c4, r4c0, r4c1, r4c2, r4c3, r4c4] cells3.forEach((cell) =\u0026gt; { cell.hide(); }) cells5.forEach((cell) =\u0026gt; { cell.hide(); }) roirslider = createSlider(0, 1, 0.3, 0.05); roirslider.position(400, 10); roirslider.style(\u0026#39;width\u0026#39;, \u0026#39;120px\u0026#39;); mrslider = createSlider(0, 3, 1.5, 0.05); mrslider.position(400, 10); mrslider.style(\u0026#39;width\u0026#39;, \u0026#39;120px\u0026#39;); dslider = createSlider(0, 2, 1, 0.05); dslider.position(550, 10); dslider.style(\u0026#39;width\u0026#39;, \u0026#39;120px\u0026#39;); modeselect = createSelect(); modeselect.position(240, 10); modeselect.option(\u0026#39;masks\u0026#39;, 0); modeselect.option(\u0026#39;region-of-interest\u0026#39;, 1); modeselect.option(\u0026#39;magnifier\u0026#39;, 2); modeselect.option(\u0026#39;brightness\u0026#39;, 3); modeselect.option(\u0026#39;tinting\u0026#39;, 4); modeselect.selected(\u0026#39;normal\u0026#39;); lmselect = createSelect(); lmselect.position(10, 10); lmselect.option(\u0026#39;original\u0026#39;, 0); lmselect.option(\u0026#39;luma\u0026#39;, 1); lmselect.option(\u0026#39;value\u0026#39;, 2); lmselect.option(\u0026#39;lightness\u0026#39;, 3); lmselect.option(\u0026#39;intensity\u0026#39;, 4); lmselect.selected(\u0026#39;original\u0026#39;); lmselect.hide(); colorA = \u0026#34;red\u0026#34;; colorB = \u0026#34;green\u0026#34;; colorC = \u0026#34;blue\u0026#34;; colorD = \u0026#34;yellow\u0026#34;; cpickerA = createColorPicker(colorA); cpickerA.position(20, 40); cpickerA.hide(); cpickerB = createColorPicker(colorB); cpickerB.position(640, 40); cpickerB.hide(); cpickerC = createColorPicker(colorC); cpickerC.position(20, 440); cpickerC.hide(); cpickerD = createColorPicker(colorD); cpickerD.position(640, 440); cpickerD.hide(); bslider = createSlider(0, 1, 1, 0.05); bslider.position(400, 10); bslider.style(\u0026#39;width\u0026#39;, \u0026#39;80px\u0026#39;); bslider.hide(); bmselect = createSelect(); bmselect.position(10, 10); bmselect.option(\u0026#39;MULTIPLY\u0026#39;, 0); bmselect.option(\u0026#39;ADD (LINEAR DODGE)\u0026#39;, 1); bmselect.option(\u0026#39;SCREEN\u0026#39;, 2); bmselect.option(\u0026#39;OVERLAY\u0026#39;, 3); bmselect.option(\u0026#39;DARKEST\u0026#39;, 4); bmselect.option(\u0026#39;LIGHTEST\u0026#39;, 5); bmselect.option(\u0026#39;COLOR BURN\u0026#39;, 6); bmselect.option(\u0026#39;LINEAR BURN\u0026#39;, 7); bmselect.option(\u0026#39;DIFFERENCE\u0026#39;, 8); bmselect.option(\u0026#39;DIVIDE\u0026#39;, 9); bmselect.option(\u0026#39;EXCLUSION\u0026#39;, 10); bmselect.option(\u0026#39;COLOR DODGE\u0026#39;, 11); bmselect.option(\u0026#39;HARD LIGHT\u0026#39;, 12); bmselect.option(\u0026#39;VIVID LIGHT\u0026#39;, 13); bmselect.option(\u0026#39;LINEAR LIGHT\u0026#39;, 14); bmselect.option(\u0026#39;PIN LIGHT\u0026#39;, 15); bmselect.option(\u0026#39;SOFT LIGHT 1\u0026#39;, 16); // photoshop bmselect.option(\u0026#39;SOFT LIGHT 2\u0026#39;, 17); // pegtop bmselect.option(\u0026#39;SOFT LIGHT 3\u0026#39;, 18); // ilussions.hu bmselect.option(\u0026#39;SOFT LIGHT 4\u0026#39;, 19); // w3C bmselect.selected(\u0026#39;MULTIPLY\u0026#39;); bmselect.hide(); video_on = createCheckbox(\u0026#39;default video\u0026#39;, false); video_on.changed(() =\u0026gt; { if (video_on.checked()) { img = createVideo([\u0026#39;/VisualComputing/docs/shaders/resources/video1.mp4\u0026#39;]); img.hide(); img.loop(); } else { img = loadImage(\u0026#39;/VisualComputing/docs/shaders/resources/download.png\u0026#39;); img.hide(); img.pause(); } maskShader.setUniform(\u0026#39;texture\u0026#39;, img); magnifierShader.setUniform(\u0026#39;texture\u0026#39;, img); brightnessShader.setUniform(\u0026#39;texture\u0026#39;, img); tintingShader.setUniform(\u0026#39;texture\u0026#39;, img); }) } function draw() { background(0); image(img, 0, 0, 700, 500); skernel = kselect.value(); // selected kernel ksize = ksselect.value(); // kernel size mode = modeselect.value(); if (mode == 0) { shader(maskShader); cpickerA.hide(); cpickerB.hide(); cpickerC.hide(); cpickerD.hide(); bmselect.hide(); bslider.hide(); ksselect.show(); kselect.show(); lmselect.hide(); roirslider.hide(); dslider.hide(); mrslider.hide(); roiradius = 100; } else if (mode == 1) { shader(maskShader); cpickerA.hide(); cpickerB.hide(); cpickerC.hide(); cpickerD.hide(); bmselect.hide(); bslider.hide(); ksselect.show(); kselect.show(); lmselect.hide(); roirslider.show(); dslider.hide(); mrslider.hide(); roiradius = roirslider.value(); } else if (mode == 2) { shader(magnifierShader); cpickerA.hide(); cpickerB.hide(); cpickerC.hide(); cpickerD.hide(); bmselect.hide(); bslider.hide(); ksselect.hide(); kselect.hide(); lmselect.hide(); roirslider.hide(); dslider.show(); mrslider.show(); mradius = mrslider.value(); depth = dslider.value(); magnifierShader.setUniform(\u0026#39;texture\u0026#39;, img); magnifierShader.setUniform(\u0026#39;mradius\u0026#39;, mradius); magnifierShader.setUniform(\u0026#39;depth\u0026#39;, depth); emitMousePosition(magnifierShader, [uniform = \u0026#39;mouse\u0026#39;]); emitResolution(magnifierShader, [uniform = \u0026#39;resolution\u0026#39;]); } else if (mode == 3) { cpickerA.hide(); cpickerB.hide(); cpickerC.hide(); cpickerD.hide(); bmselect.hide(); bslider.hide(); ksselect.hide(); kselect.hide(); lmselect.show(); roirslider.hide(); dslider.hide(); mrslider.hide(); shader(brightnessShader); brightnessShader.setUniform(\u0026#39;texture\u0026#39;, img); brightnessShader.setUniform(\u0026#39;mode\u0026#39;, lmselect.value()); } else if (mode == 4) { ksselect.hide(); kselect.hide(); lmselect.hide(); roirslider.hide(); dslider.hide(); mrslider.hide(); cpickerA.show(); colorA = cpickerA.color() cpickerB.show(); colorB = cpickerB.color() cpickerC.show(); colorC = cpickerC.color() cpickerD.show(); colorD = cpickerD.color() bmselect.show(); bmode = bmselect.value(); bslider.show(); brightness = bslider.value(); shader(tintingShader); beginShape(); fill(colorA); vertex(-width / 2, -height / 2); fill(colorB); vertex(width / 2, -height / 2); fill(colorC); vertex(width / 2, height / 2); fill(colorD); vertex(-width / 2, height / 2); endShape(); tintingShader.setUniform(\u0026#39;brightness\u0026#39;, brightness); tintingShader.setUniform(\u0026#39;mode\u0026#39;, bmode); tintingShader.setUniform(\u0026#39;texture\u0026#39;, img); } maskShader.setUniform(\u0026#39;texture\u0026#39;, img); maskShader.setUniform(\u0026#39;texOffset\u0026#39;, [1 / img.width, 1 / img.height]); maskShader.setUniform(\u0026#39;ksize\u0026#39;, ksize); maskShader.setUniform(\u0026#39;roiradius\u0026#39;, roiradius); maskShader.setUniform(\u0026#39;mode\u0026#39;, mode); emitMousePosition(maskShader, [uniform = \u0026#39;mouse\u0026#39;]); emitResolution(maskShader, [uniform = \u0026#39;resolution\u0026#39;]); if (skernel == 9) { if (ksize == 3) { cells5.forEach((cell) =\u0026gt; { cell.hide(); }) cells3.forEach((cell) =\u0026gt; { cell.show(); }) } else if (ksize == 5) { cells3.forEach((cell) =\u0026gt; { cell.hide(); }) cells5.forEach((cell) =\u0026gt; { cell.show(); }) } mask3 = [r0c0.value(), r0c1.value(), r0c2.value(), r1c0.value(), r1c1.value(), r1c2.value(), r2c0.value(), r2c1.value(), r2c2.value()] mask5 = [r0c0.value(), r0c1.value(), r0c2.value(), r0c3.value(), r0c4.value(), r1c0.value(), r1c1.value(), r1c2.value(), r1c3.value(), r1c4.value(), r2c0.value(), r2c1.value(), r2c2.value(), r2c3.value(), r2c4.value(), r3c0.value(), r3c1.value(), r3c2.value(), r3c3.value(), r3c4.value(), r4c0.value(), r4c1.value(), r4c2.value(), r4c3.value(), r4c4.value(),] } else { cells3.forEach((cell) =\u0026gt; { cell.hide(); }) cells5.forEach((cell) =\u0026gt; { cell.hide(); }) if (skernel == 0) { // identity mask3 = [0, 0, 0, 0, 1, 0, 0, 0, 0]; mask5 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] } else if (skernel == 1) { // ridges mask3 = [-1, -1, -1, -1, 8, -1, -1, -1, -1]; mask5 = [-1, -1, -1, -1, -1, -1, 1, 1, 1, -1, -1, 1, 8, 1, -1, -1, 1, 1, 1, -1, -1, -1, -1, -1, -1]; } else if (skernel == 2) { // sharpen mask3 = [0, -1, 0, -1, 5, -1, 0, -1, 0]; mask5 = [0, 0, -1, 0, 0, 0, -1, 1, -1, 0, -1, 1, 5, 1, -1, 0, -1, 1, -1, 0, 0, 0, -1, 0, 0]; } else if (skernel == 3) { // blur mask3 = [0.0625, 0.125, 0.0625, 0.125, 0.25, 0.125, 0.0625, 0.125, 0.0625]; // https://en.wikipedia.org/wiki/Kernel_(image_processing) mask5 = [1/256, 4/256, 6/256, 4/256, 1/256, 4/256, 16/256, 24/256, 16/256, 4/256, 6/256, 24/256, 36/256, 24/256, 6/256, 4/256, 16/256, 24/256, 16/256, 4/256, 1/256, 4/256, 6/256, 4/256, 1/256]; } else if (skernel == 4) { // top sobel mask3 = [1, 2, 1, 0, 0, 0, -1, -2, -1]; // https://www.researchgate.net/figure/Sobel-convolution-kernels5x5_fig1_49619233 mask5 = [2, 2, 4, 2, 2, 1, 1, 2, 1, 1, 0, 0, 0, 0, 0, -1, -1, -2, -1, -1, -2, -2, -4, -2, -2]; } else if (skernel == 5) { // right sobel mask3 = [-1, 0, 1, -2, 0, 2, -1, 0, 1]; mask5 = [-2, -1, 0, 1, 2, -2, -1, 0, 1, 2, -4, -2, 0, 2, 4, -2, -1, 0, 1, 2, -2, -1, 0, 1, 2,]; } else if (skernel == 6) { // bottom sobel mask3 = [-1, -2, -1, 0, 0, 0, 1, 2, 1]; mask5 = [-2, -2, -4, -2, -2, -1, -1, -2, -1, -1, 0, 0, 0, 0, 0, 1, 1, 2, 1, 1, 2, 2, 4, 2, 2]; } else if (skernel == 7) { // left sobel mask3 = [1, 0, -1, 2, 0, -2, 1, 0, -1]; mask5 = [2, 1, 0, -1, -2, 2, 1, 0, -1, -2, 4, 2, 0, -2, -4, 2, 1, 0, -1, -2, 2, 1, 0, -1, -2,]; } else if (skernel == 8) { // emboss mask3 = [-2, -1, 0, -1, 1, 1, 0, 1, 2] // https://stackoverflow.com/questions/61297368/what-is-the-5x5-equivalent-of-the-3x3-emboss-kernel mask5 = [-2, 0, -1, 0, 0, 0, -2, -1, 0, 0, -1, -1, 1, 1, 1, 0, 0, 1, 2, 0, 0, 0, 1, 0, 2]; } } if (ksize == 3) { maskShader.setUniform(\u0026#39;mask3\u0026#39;, mask3); } else if (ksize == 5) { maskShader.setUniform(\u0026#39;mask5\u0026#39;, mask5); } quad(-width / 2, -height / 2, width / 2, -height / 2, width / 2, height / 2, -width / 2, height / 2); } function handleFile(file) { if (file.type === \u0026#39;image\u0026#39;) { img = createImg(file.data, \u0026#39;\u0026#39;); img.hide(); } else if (file.type === \u0026#39;video\u0026#39;) { img = createVideo([file.data]); img.hide(); img.loop(); } } Mask Shader Code precision mediump float; uniform sampler2D texture; uniform vec2 texOffset; uniform float mask3[9]; uniform float mask5[25]; uniform int ksize; // kernel size varying vec2 texcoords2; uniform float roiradius; uniform float mradius; uniform vec2 mouse; uniform vec2 resolution; uniform int mode; uniform float depth; void main() { vec2 st = gl_FragCoord.xy / resolution; vec2 center = mouse.xy / resolution; vec4 texel = texture2D(texture, texcoords2); vec4 convolution; if (ksize == 3) { // col 0 vec2 tc0 = texcoords2 + vec2(-texOffset.s, -texOffset.t); vec2 tc1 = texcoords2 + vec2( 0.0, -texOffset.t); vec2 tc2 = texcoords2 + vec2(+texOffset.s, -texOffset.t); // col 1 vec2 tc3 = texcoords2 + vec2(-texOffset.s, 0.0); vec2 tc4 = texcoords2 + vec2( 0.0, 0.0); vec2 tc5 = texcoords2 + vec2(+texOffset.s, 0.0); // col 2 vec2 tc6 = texcoords2 + vec2(-texOffset.s, +texOffset.t); vec2 tc7 = texcoords2 + vec2( 0.0, +texOffset.t); vec2 tc8 = texcoords2 + vec2(+texOffset.s, +texOffset.t); vec4 rgba[9]; rgba[0] = texture2D(texture, tc0); rgba[1] = texture2D(texture, tc1); rgba[2] = texture2D(texture, tc2); rgba[3] = texture2D(texture, tc3); rgba[4] = texture2D(texture, tc4); rgba[5] = texture2D(texture, tc5); rgba[6] = texture2D(texture, tc6); rgba[7] = texture2D(texture, tc7); rgba[8] = texture2D(texture, tc8); for (int i = 0; i \u0026lt; 9; i++) { convolution += rgba[i] * mask3[i]; } } else if (ksize == 5) { // row 0 vec2 tc0 = texcoords2 + vec2(- 2. * texOffset.s, - 2. * texOffset.t); vec2 tc1 = texcoords2 + vec2(- 2. * texOffset.s, - 1. * texOffset.t); vec2 tc2 = texcoords2 + vec2(- 2. * texOffset.s, 0. * texOffset.t); vec2 tc3 = texcoords2 + vec2(- 2. * texOffset.s, + 1. * texOffset.t); vec2 tc4 = texcoords2 + vec2(- 2. * texOffset.s, + 2. * texOffset.t); // row 1 vec2 tc5 = texcoords2 + vec2(- 1. * texOffset.s, - 2. * texOffset.t); vec2 tc6 = texcoords2 + vec2(- 1. * texOffset.s, - 1. * texOffset.t); vec2 tc7 = texcoords2 + vec2(- 1. * texOffset.s, 0. * texOffset.t); vec2 tc8 = texcoords2 + vec2(- 1. * texOffset.s, + 1. * texOffset.t); vec2 tc9 = texcoords2 + vec2(- 1. * texOffset.s, + 2. * texOffset.t); // row 2 vec2 tc10 = texcoords2 + vec2(0. * texOffset.s, - 2. * texOffset.t); vec2 tc11 = texcoords2 + vec2(0. * texOffset.s, - 1. * texOffset.t); vec2 tc12 = texcoords2 + vec2(0. * texOffset.s, 0. * texOffset.t); vec2 tc13 = texcoords2 + vec2(0. * texOffset.s, + 1. * texOffset.t); vec2 tc14 = texcoords2 + vec2(0. * texOffset.s, + 2. * texOffset.t); // row 3 vec2 tc15 = texcoords2 + vec2(+ 1. * texOffset.s, - 2. * texOffset.t); vec2 tc16 = texcoords2 + vec2(+ 1. * texOffset.s, - 1. * texOffset.t); vec2 tc17 = texcoords2 + vec2(+ 1. * texOffset.s, 0. * texOffset.t); vec2 tc18 = texcoords2 + vec2(+ 1. * texOffset.s, + 1. * texOffset.t); vec2 tc19 = texcoords2 + vec2(+ 1. * texOffset.s, + 2. * texOffset.t); // row 4 vec2 tc20 = texcoords2 + vec2(+ 2. * texOffset.s, - 2. * texOffset.t); vec2 tc21 = texcoords2 + vec2(+ 2. * texOffset.s, - 1. * texOffset.t); vec2 tc22 = texcoords2 + vec2(+ 2. * texOffset.s, 0. * texOffset.t); vec2 tc23 = texcoords2 + vec2(+ 2. * texOffset.s, + 1. * texOffset.t); vec2 tc24 = texcoords2 + vec2(+ 2. * texOffset.s, + 2. * texOffset.t); vec4 rgba[25]; rgba[0] = texture2D(texture, tc0); rgba[1] = texture2D(texture, tc1); rgba[2] = texture2D(texture, tc2); rgba[3] = texture2D(texture, tc3); rgba[4] = texture2D(texture, tc4); rgba[5] = texture2D(texture, tc5); rgba[6] = texture2D(texture, tc6); rgba[7] = texture2D(texture, tc7); rgba[8] = texture2D(texture, tc8); rgba[9] = texture2D(texture, tc9); rgba[10] = texture2D(texture, tc10); rgba[11] = texture2D(texture, tc11); rgba[12] = texture2D(texture, tc12); rgba[13] = texture2D(texture, tc13); rgba[14] = texture2D(texture, tc14); rgba[15] = texture2D(texture, tc15); rgba[16] = texture2D(texture, tc16); rgba[17] = texture2D(texture, tc17); rgba[18] = texture2D(texture, tc18); rgba[19] = texture2D(texture, tc19); rgba[20] = texture2D(texture, tc20); rgba[21] = texture2D(texture, tc21); rgba[22] = texture2D(texture, tc22); rgba[23] = texture2D(texture, tc23); rgba[24] = texture2D(texture, tc24); for (int i = 0; i \u0026lt; 25; i++) { convolution += rgba[i] * mask5[i]; } } gl_FragColor = (distance(st, center) \u0026lt; roiradius) ? vec4(convolution.rgb, 1.0) : texel; } Magnifier Shader Code precision mediump float; uniform sampler2D texture; varying vec2 texcoords2; uniform float mradius; uniform vec2 mouse; uniform vec2 resolution; uniform float depth; void main() { // https://www.shadertoy.com/view/llsSz7 vec2 uv = texcoords2.xy; vec2 center = vec2(mouse.x, 500. - mouse.y) / resolution.xy; float ax = ((uv.x - center.x) * (uv.x - center.x)) / (0.25 * 0.25) + ((uv.y - center.y) * (uv.y - center.y)) / (0.25 / (resolution.x / resolution.y)); float dx = 0.0 + (- depth / mradius) * ax + (depth / (mradius * mradius)) * ax * ax; float f = (ax + dx); if (ax \u0026gt; mradius) f = ax; vec2 magnifierArea = center + (uv - center) * f / ax; gl_FragColor = texture2D(texture, magnifierArea); } "},{"id":7,"href":"/VisualComputing/docs/shaders/ProceduralTexturing/","title":"Procedural Texturing","section":"Shaders","content":" Exercise # Adapt other patterns from the book of shaders (refer also to the shadertoy collection) and map them as textures onto other 3D shapes.\nProcedural Texturing # En este ejercicio, se implementaron dos patrones. Uno tomado de The Book of Shaders: Random llamado Mosaic y otro tomado de generative art deco 4 (Shadertoy) y que aplica el concepto de Chromatic aberration.\nPor defecto se mostrará este segundo shader sobre un conjunto de conos generados aleatoriamente y que se mueven cíclicamente por el espacio (mod 400) mientras rotan.\nSi el usuario selecciona mosaic del selector de shaders, los objetos se transforman en esferas y se aplica la textura procedimental mosaic.\nControles # Select: selecciona el shader de textura procedimental que desea visualizar Sketch Code let angle = 0; let positions = []; // will contain objects 3D positions let easycam; let P; let pg; let cabberShader; let mosaicShader; let i = 1; let texselect; let tex; function preload() { cabberShader = readShader(\u0026#39;/VisualComputing/docs/shaders/fragments/cabber.frag\u0026#39;, { matrices: Tree.NONE, varyings: Tree.NONE }); mosaicShader = readShader(\u0026#39;/VisualComputing/docs/shaders/fragments/mosaic.frag\u0026#39;, { matrices: Tree.NONE, varyings: Tree.NONE }); } function setup() { createCanvas(500, 500, WEBGL); pg = createGraphics(400, 400, WEBGL); textureMode(NORMAL); noStroke(); pg.noStroke(); pg.textureMode(NORMAL); easycam = createEasyCam(); let state = { distance: 600, center: [200, 200, 200], rotation: [1, -1, 0, 0], }; easycam.setState(state, 1000); // 50 objects are placed throughout the space with random positions. for (let i = 0; i \u0026lt; 30; i++) { let x = randomint(-400, 400); let y = randomint(-400, 400); let z = randomint(-400, 400); positions.push([x, y, z]); } texselect = createSelect(); texselect.position(10, 10); texselect.option(\u0026#39;cabber\u0026#39;, 0); texselect.option(\u0026#39;mosaic\u0026#39;, 1); texselect.selected(\u0026#39;cabber\u0026#39;); } function draw() { tex = texselect.value(); background(0); P = easycam.getPosition(); let size = 50; let ssize = 300; let chromabber = 0.01; for (let i = 0; i \u0026lt; positions.length; i++) { cabberShader.setUniform(\u0026#39;SHAPE_SIZE\u0026#39;, ssize/1000); cabberShader.setUniform(\u0026#39;CHROMATIC_ABBERATION\u0026#39;, chromabber); cabberShader.setUniform(\u0026#39;u_time\u0026#39;, frameCount * 0.1); mosaicShader.setUniform(\u0026#39;u_time\u0026#39;, frameCount * 0.1); pg.emitResolution(cabberShader); pg.emitResolution(mosaicShader); if (tex == 0) pg.shader(cabberShader); else if (tex == 1) pg.shader(mosaicShader); pg.quad(-1, -1, 1, -1, 1, 1, -1, 1); texture(pg); push(); positions[i][0] = (positions[i][0] + 2) % 400; positions[i][1] = (positions[i][1] + 2) % 400; positions[i][2] = (positions[i][2] + 2) % 400; translate(positions[i][0], positions[i][1], positions[i][2]); // with push and pop, translation and rotation of each object is independent of each other. rotateX(angle); rotateY(angle * 0.4); if (tex == 0) cone(size); else if (tex == 1) sphere(size); pop(); ssize += 20; size += 1; chromabber += 0.002; if (tex == 1) angle += 0.001; } } function randomint(min, max) { min = Math.ceil(min); max = Math.floor(max); return Math.floor(Math.random() * (max - min + 1) + min); } Mosaic Shader Code // Author @patriciogv - 2015 // Title: Mosaic #ifdef GL_ES precision mediump float; #endif uniform vec2 u_resolution; uniform vec2 u_mouse; uniform float u_time; float random (vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123); } void main() { vec2 st = gl_FragCoord.xy/u_resolution.xy; st *= 10.0; // Scale the coordinate system by 10 vec2 ipos = floor(st); // get the integer coords vec2 fpos = fract(st); // get the fractional coords // Assign a random value based on the integer coord vec3 color = vec3(random( ipos )); // Uncomment to see the subdivided grid // color = vec3(fpos,0.0); gl_FragColor = vec4(color,1.0); } Chromatic Abberration Shader Code // Fork of \u0026#34;generative art deco 3\u0026#34; by morisil. https://shadertoy.com/view/mdl3WX // 2022-10-28 00:47:55 // Fork of \u0026#34;generative art deco 2\u0026#34; by morisil. https://shadertoy.com/view/ftVBDz // 2022-10-27 22:34:54 // Fork of \u0026#34;generative art deco\u0026#34; by morisil. https://shadertoy.com/view/7sKfDd // 2022-09-28 11:25:15 // Copyright Kazimierz Pogoda, 2022 - https://xemantic.com/ // I am the sole copyright owner of this Work. // You cannot host, display, distribute or share this Work in any form, // including physical and digital. You cannot use this Work in any // commercial or non-commercial product, website or project. You cannot // sell this Work and you cannot mint an NFTs of it. // I share this Work for educational purposes, and you can link to it, // through an URL, proper attribution and unmodified screenshot, as part // of your educational material. If these conditions are too restrictive // please contact me and we\u0026#39;ll definitely work it out. // copyright statement borrowed from Inigo Quilez // Music by Giovanni Sollima, L\u0026#39;invenzione del nero: // https://soundcloud.com/giovanni-sollima/linvenzione-del-nero // See also The Mathematics of Perception to check the ideas behind: // https://www.shadertoy.com/view/7sVBzK precision mediump float; uniform float SHAPE_SIZE; uniform float CHROMATIC_ABBERATION; const float ITERATIONS = 10.; const float INITIAL_LUMA = .5; uniform vec2 u_resolution; uniform float u_time; const float PI = 3.14159265359; const float TWO_PI = 6.28318530718; mat2 rotate2d(float _angle){ return mat2(cos(_angle),-sin(_angle), sin(_angle),cos(_angle)); } float sdPolygon( float angle, float distance) { float segment = TWO_PI / 4.0; return cos(floor(.5 + angle / segment) * segment - angle) * distance; } float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123); } float getColorComponent( vec2 st, float modScale, float blur) { vec2 modSt = mod(st, 1. / modScale) * modScale * 2. - 1.; float dist = length(modSt); float angle = atan(modSt.x, modSt.y) + sin(u_time * .08) * 9.0; float shapeMap = smoothstep(SHAPE_SIZE + blur, SHAPE_SIZE - blur, sin(dist * 3.0) * .5 + .5); return shapeMap; } void main() { vec2 st = (2.* gl_FragCoord.xy - u_resolution) / min(u_resolution.x, u_resolution.y); vec2 origSt = st; st *= rotate2d(sin(u_time * .14) * .3); st *= (sin(u_time * .15) + 2.) * .3; st *= log(length(st * .428)) * 1.1; float blur = .4 + sin(u_time * .52) * .2; float modScale = 1.; vec3 color = vec3(0); float luma = INITIAL_LUMA; for (float i = 0.; i \u0026lt; ITERATIONS; i++) { vec2 center = st + vec2(sin(u_time * .12), cos(u_time * .13)); //center += pow(length(center), 1.); vec3 shapeColor = vec3( getColorComponent(center - st * CHROMATIC_ABBERATION, modScale, blur), getColorComponent(center, modScale, blur), getColorComponent(center + st * CHROMATIC_ABBERATION, modScale, blur) ) * luma; st *= 1.1 + getColorComponent(center, modScale, .04) * 1.2; st *= rotate2d(sin(u_time * .05) * 1.33); color += shapeColor; color = clamp(color, 0., 1.); // if (color == vec3(1)) break; luma *= .6; blur *= .63; } const float GRADING_INTENSITY = .4; vec3 topGrading = vec3( 1. + sin(u_time * 1.13 * .3) * GRADING_INTENSITY, 1. + sin(u_time * 1.23 * .3) * GRADING_INTENSITY, 1. - sin(u_time * 1.33 * .3) * GRADING_INTENSITY ); vec3 bottomGrading = vec3( 1. - sin(u_time * 1.43 * .3) * GRADING_INTENSITY, 1. - sin(u_time * 1.53 * .3) * GRADING_INTENSITY, 1. + sin(u_time * 1.63 * .3) * GRADING_INTENSITY ); float origDist = length(origSt); vec3 colorGrading = mix(topGrading, bottomGrading, origDist - .5); gl_FragColor = vec4(pow(color.rgb, colorGrading), 1.); gl_FragColor *= smoothstep(2.1, .7, origDist); } "},{"id":8,"href":"/VisualComputing/docs/shaders/non-euclidean_geometry/","title":"Non-Euclidean geometry","section":"Shaders","content":" Non-Euclidean geometry # Marco teórico # Ejercicio # Código let edge = 80; let button1, button2, button3; let use = 1; let bedge = 160; let oedge = 100; let oredge = oedge * Math.sqrt(3); let arrow; let arrowTex; let bee; let beeTex; let tiger; let tigerTex; let tree; let treeTex; let penguin; let penguinTex; let fish; let fishTex; let crown; let crowTex; let tower; let towerTex; let texShader; function preload() { // no varyings need to be emitted from the vertex shader texShader = readShader(\u0026#39;/VisualComputing/sketches/Non_Euclid/non_euclidean.frag\u0026#39;, { varyings: Tree.NONE }); arrow = loadModel(\u0026#39;/VisualComputing/sketches/non_euclid_obj/arrow_heart.obj\u0026#39;, true); bee = loadModel(\u0026#39;/VisualComputing/sketches/non_euclid_obj/bee.obj\u0026#39;, true); tiger = loadModel(\u0026#39;/VisualComputing/sketches/non_euclid_obj/tiger_tank.obj\u0026#39;, true); tree = loadModel(\u0026#39;/VisualComputing/sketches/non_euclid_obj/tree.obj\u0026#39;, true); penguin = loadModel(\u0026#39;/VisualComputing/sketches/non_euclid_obj/penguin.obj\u0026#39;, true); fish = loadModel(\u0026#39;/VisualComputing/sketches/non_euclid_obj/fish.obj\u0026#39;, true); tower = loadModel(\u0026#39;/VisualComputing/sketches/non_euclid_obj/eiffel_tower.obj\u0026#39;, true); crow = loadModel(\u0026#39;/VisualComputing/sketches/non_euclid_obj/crow.obj\u0026#39;, true); } function setup() { createCanvas(400, 400, WEBGL); // no need to normalize the texture // textureMode(NORMAL); // Make buttons button1 = createButton(\u0026#39;Cube\u0026#39;); button2 = createButton(\u0026#39;Pyramid\u0026#39;); button3 = createButton(\u0026#39;Octahedron\u0026#39;); button1.mousePressed(showCube); button2.mousePressed(showPyramid); button3.mousePressed(showOctahedron); button1.position(10,10); button2.position(10+button1.width,10); button3.position(10+button1.width+button2.width,10); shader(texShader); // resolution will be used to sample the offscreen textures emitResolution(texShader); easycam = createEasyCam(); // teapotTex = createGraphics(width, height, WEBGL); // bunnyTex = createGraphics(width, height, WEBGL); arrowTex = createGraphics(width, height, WEBGL); beeTex = createGraphics(width, height, WEBGL); tigerTex = createGraphics(width, height, WEBGL); treeTex = createGraphics(width, height, WEBGL); penguinTex = createGraphics(width, height, WEBGL); fishTex = createGraphics(width, height, WEBGL); crowTex = createGraphics(width, height, WEBGL); towerTex = createGraphics(width, height, WEBGL); } function draw() { // 1. compute current main canvas camera params let position = treeLocation(); let center = p5.Vector.add(position, treeDisplacement()); let up = treeDisplacement(Tree.j); // in case the current camera projection params are needed check: // https://github.com/VisualComputing/p5.treegl#frustum-queries // 2. offscreen rendering // bunny graphics // bunnyTex.background(200); // bunnyTex.reset(); // bunnyTex.camera(position.x, position.y, position.z, // center.x, center.y, center.z, // up.x, up.y, up.z); // bunnyTex.push(); // bunnyTex.noStroke(); // bunnyTex.fill(\u0026#39;red\u0026#39;); // // most models use positive y-coordinates // bunnyTex.scale(1, -1); // bunnyTex.scale(0.8);// only bunny // bunnyTex.model(bunny); // bunnyTex.pop(); // teapot graphics // teapotTex.background(200); // teapotTex.reset(); // teapotTex.camera(position.x, position.y, position.z, // center.x, center.y, center.z, // up.x, up.y, up.z); // teapotTex.push(); // teapotTex.noStroke(); // teapotTex.fill(\u0026#39;blue\u0026#39;); // teapotTex.scale(1, -1); // teapotTex.model(teapot); // teapotTex.pop(); // 1-arrow graphics arrowTex.background(200); arrowTex.reset(); arrowTex.camera(position.x, position.y, position.z, center.x, center.y, center.z, up.x, up.y, up.z); arrowTex.push(); arrowTex.noStroke(); arrowTex.fill(\u0026#39;#E91E63\u0026#39;); // most models use positive y-coordinates arrowTex.scale(1, -1); arrowTex.scale(0.5); arrowTex.model(arrow); arrowTex.pop(); // 2-bee graphics beeTex.background(200); beeTex.reset(); beeTex.camera(position.x, position.y, position.z, center.x, center.y, center.z, up.x, up.y, up.z); beeTex.push(); beeTex.noStroke(); beeTex.fill(\u0026#39;#FFEB3B\u0026#39;); // most models use positive y-coordinates beeTex.scale(1, -1); beeTex.scale(0.8); beeTex.model(bee); beeTex.pop(); // 3-tiger graphics tigerTex.background(200); tigerTex.reset(); tigerTex.camera(position.x, position.y, position.z, center.x, center.y, center.z, up.x, up.y, up.z); tigerTex.push(); tigerTex.noStroke(); tigerTex.fill(\u0026#39;#9E9E9E\u0026#39;); // most models use positive y-coordinates tigerTex.scale(1, -1); tigerTex.scale(0.8); tigerTex.model(tiger); tigerTex.pop(); // 4-tree graphics treeTex.background(200); treeTex.reset(); treeTex.camera(position.x, position.y, position.z, center.x, center.y, center.z, up.x, up.y, up.z); treeTex.push(); treeTex.noStroke(); treeTex.fill(\u0026#39;#4CAF50\u0026#39;); // most models use positive y-coordinates treeTex.scale(1, -1); treeTex.scale(0.8); treeTex.model(tree); treeTex.pop(); // 5-penguin graphics penguinTex.background(200); penguinTex.reset(); penguinTex.camera(position.x, position.y, position.z, center.x, center.y, center.z, up.x, up.y, up.z); penguinTex.push(); penguinTex.noStroke(); penguinTex.fill(\u0026#39;#795548\u0026#39;); // most models use positive y-coordinates penguinTex.scale(1, -1); penguinTex.scale(0.8); penguinTex.model(penguin); penguinTex.pop(); // 6-crow graphics crowTex.background(200); crowTex.reset(); crowTex.camera(position.x, position.y, position.z, center.x, center.y, center.z, up.x, up.y, up.z); crowTex.push(); crowTex.noStroke(); crowTex.fill(\u0026#39;#673AB7\u0026#39;); // most models use positive y-coordinates crowTex.scale(1, -1); crowTex.scale(0.8); crowTex.model(crow); crowTex.pop(); // 7-tower graphics towerTex.background(200); towerTex.reset(); towerTex.camera(position.x, position.y, position.z, center.x, center.y, center.z, up.x, up.y, up.z); towerTex.push(); towerTex.noStroke(); towerTex.fill(\u0026#39;#FFC107\u0026#39;); // most models use positive y-coordinates towerTex.scale(1, -1); towerTex.scale(0.8);// only bunny towerTex.model(tower); towerTex.pop(); // 8-fish graphics fishTex.background(200); fishTex.reset(); fishTex.camera(position.x, position.y, position.z, center.x, center.y, center.z, up.x, up.y, up.z); fishTex.push(); fishTex.noStroke(); fishTex.fill(\u0026#39;#07FFE5\u0026#39;); // most models use positive y-coordinates fishTex.scale(1, -1); fishTex.scale(0.8);// only bunny fishTex.model(fish); fishTex.pop(); if (use == 1) { cube(); } else if(use == 2) { pyramid(); } else if(use == 3) { octahedron(); } } function cube(){ // 3. main canvas background(0); push(); // front (+z) stroke(\u0026#39;#FFC107\u0026#39;); strokeWeight(5); texShader.setUniform(\u0026#39;texture\u0026#39;, crowTex); beginShape(); vertex(-edge, -edge, +edge); vertex(+edge, -edge, +edge); vertex(+edge, +edge, +edge); vertex(-edge, +edge, +edge); endShape(CLOSE); // right (+x) texShader.setUniform(\u0026#39;texture\u0026#39;, fishTex); beginShape(); vertex(+edge, -edge, +edge); vertex(+edge, -edge, -edge); vertex(+edge, +edge, -edge); vertex(+edge, +edge, +edge); endShape(CLOSE); // left (-x) texShader.setUniform(\u0026#39;texture\u0026#39;, penguinTex); beginShape(); vertex(-edge, -edge, +edge); vertex(-edge, +edge, +edge); vertex(-edge, +edge, -edge); vertex(-edge, -edge, -edge); endShape(CLOSE); // back (-z) texShader.setUniform(\u0026#39;texture\u0026#39;, treeTex); beginShape(); vertex(-edge, -edge, -edge); vertex(-edge, +edge, -edge); vertex(+edge, +edge, -edge); vertex(+edge, -edge, -edge); endShape(CLOSE); // bottom (+y) texShader.setUniform(\u0026#39;texture\u0026#39;, beeTex); beginShape(); vertex(-edge, +edge, +edge); vertex(+edge, +edge, +edge); vertex(+edge, +edge, -edge); vertex(-edge, +edge, -edge); endShape(CLOSE); // top (-y) texShader.setUniform(\u0026#39;texture\u0026#39;, arrowTex); beginShape(); vertex(-edge, -edge, +edge); vertex(+edge, -edge, +edge); vertex(+edge, -edge, -edge); vertex(-edge, -edge, -edge); endShape(CLOSE); pop(); } function pyramid(){ // 3. main canvas background(0); push(); // front (+z) stroke(\u0026#39;#FFC107\u0026#39;); strokeWeight(5); texShader.setUniform(\u0026#39;texture\u0026#39;, crowTex); beginShape(); vertex(-edge, +edge, +bedge); vertex(+edge, +edge, +bedge); vertex(0, -bedge, 0); endShape(CLOSE); // right (+x) texShader.setUniform(\u0026#39;texture\u0026#39;, fishTex); beginShape(); vertex(+edge, +edge, +bedge); vertex(+edge, +edge, -bedge); vertex(0, -bedge, 0); endShape(CLOSE); // left (-x) texShader.setUniform(\u0026#39;texture\u0026#39;, penguinTex); beginShape(); vertex(-edge, +edge, +bedge); vertex(-edge, +edge, -bedge); vertex(0, -bedge, 0); endShape(CLOSE); // back (-z) texShader.setUniform(\u0026#39;texture\u0026#39;, treeTex); beginShape(); vertex(-edge, +edge, -bedge); vertex(+edge, +edge, -bedge); vertex(0, -bedge, 0); endShape(CLOSE); // bottom (+y) texShader.setUniform(\u0026#39;texture\u0026#39;, beeTex); beginShape(); vertex(-edge, +edge, +bedge); vertex(+edge, +edge, +bedge); vertex(+edge, +edge, -bedge); vertex(-edge, +edge, -bedge); endShape(CLOSE); pop(); } function octahedron(){ // 3. main canvas background(0); push(); // frontup (+z-y) stroke(\u0026#39;#FFC107\u0026#39;); strokeWeight(5); texShader.setUniform(\u0026#39;texture\u0026#39;, crowTex); beginShape(); vertex(-oedge, 0, +oedge); vertex(+oedge, 0, +oedge); vertex(0, -oredge, 0); endShape(CLOSE); // rightup (+x-y) texShader.setUniform(\u0026#39;texture\u0026#39;, fishTex); beginShape(); vertex(+oedge, 0, +oedge); vertex(+oedge, 0, -oedge); vertex(0, -oredge, 0); endShape(CLOSE); // leftup (-x-y) texShader.setUniform(\u0026#39;texture\u0026#39;, penguinTex); beginShape(); vertex(-oedge, 0, +oedge); vertex(-oedge, 0, -oedge); vertex(0, -oredge, 0); endShape(CLOSE); // backup (-z-y) texShader.setUniform(\u0026#39;texture\u0026#39;, towerTex); beginShape(); vertex(-oedge, 0, -oedge); vertex(+oedge, 0, -oedge); vertex(0, -oredge, 0); endShape(CLOSE); // frontdw (+z+y) strokeWeight(5); texShader.setUniform(\u0026#39;texture\u0026#39;, beeTex); beginShape(); vertex(-oedge, 0, +oedge); vertex(+oedge, 0, +oedge); vertex(0, +oredge, 0); endShape(CLOSE); // rightdw (+x+y) texShader.setUniform(\u0026#39;texture\u0026#39;, tigerTex); beginShape(); vertex(+oedge, 0, +oedge); vertex(+oedge, 0, -oedge); vertex(0, +oredge, 0); endShape(CLOSE); // leftdw (-x+y) texShader.setUniform(\u0026#39;texture\u0026#39;, treeTex); beginShape(); vertex(-oedge, 0, +oedge); vertex(-oedge, 0, -oedge); vertex(0, +oredge, 0); endShape(CLOSE); // backdw (-z+y) texShader.setUniform(\u0026#39;texture\u0026#39;, arrowTex); beginShape(); vertex(-oedge, 0, -oedge); vertex(+oedge, 0, -oedge); vertex(0, +oredge, 0); endShape(CLOSE); pop(); } function showCube(){ use = 1; } function showPyramid(){ use = 2; } function showOctahedron(){ use = 3; } "},{"id":9,"href":"/VisualComputing/docs/shaders/SpatialCoherence/","title":"Spatial Coherence","section":"Shaders","content":" Exercise # Implement your own source dataset and a mechanism to select different images from it. Implement a pixelator in software that doesn’t use spatial coherence and compare the results with those obtained here. Spatial Coherence # En este ejericio se hace una implementación del pixelado de imágenes usando coherencia espacial. El shader pixelator recibe la imagen y la resolución a utilizar. Una resolución de 30 significa que la imagen pixelada tendrá 30 pixeles de baja resolución (grandes) en cada lado.\nEl mecanismo de coherencia espacial opera de la siguiente forma: Para cada texel se recibe una coordenada normalizada [0..1]. Cada componente se multiplica por la resolución por lo que si esta es 30, ahora [0..30]. Luego, a estas componentes se les calcula la función piso. De esta manera, por ejemplo, todas las coordenadas dentro del espacio [2, 3)x[2, 3) serán mapeadas a la coordenada (2, 2). Esta coordenada se divide entre la resolución para volver a obtener valores normalizadas. El color de la coordenada (2, 2) es asignado a todos los texeles en [2, 3)x[2, 3). Aquí la coherencia espacial sea aplica porque se asume que ese color será cercano a los colores de todos los texeles que se mapean a dicha coordenada, aunque no sea cierto en todos los casos, pero siendo muy probable.\nSe añadó una implementación que no usa coherencia espacial para que el usuario pueda comparar los resultados. Esta otra implementación, pinta cada pixel de baja resolución con el color promedio de los colores de los pixeles que se mapean a dicha coordenada. Esta aplicación fue implementada por software, es decir, no se usan shaders. El usuario debe subir la imagen que quiere comparar manualmentee a ambas implementaciones y mover el slider para que ambas tengan la misma resolución.\nSe observará que no hay gran diferencia en los colores usados en los pixeles de baja resolución. Tal vez incluso parezca que la coherencia espacial muestra la imagen pixelada con un poco más de detalle, mientras que la que usa el promedio de los colores pareciera que estuviera pasando un efecto de blur o lo menos algo similar \u0026hellip;).\nLa implementación sin coherencia espacial no acepta videos, por lo que solo podrá hacer la comparación con imágenes.\nControles # Botón Choose File: para cargar una imagen o video Checkbox Default Video: marcar para usar el video por defecto, desmarcar para usar la imagen por defecto Slider: define la resolución (por defecto 30, es decir 30 pixeles de baja resolución por cada lado de la cuadrícula). El mínimo valor es 1 y el máximo 150. Una resolución mayor, implica más pixeles, y por tanto, de menor tamaño cada vez. El tamaño de la cuadrícula es de 600px x 600px por lo que una resolución de 150 implica pixeles de baja resolución de dimensiones 4px x 4px. Select: para decidir si ver la imagen pixelada o la original Input: ingrese un número entre 1 y 30 para escoger una imagen del dataset. El dataset se muestra en orden abajo de esta aplicación. Observe por ejemplo que panda rojo le corresponde el número 7. Una vez ingresado un número puede usar las flechas de su teclado para cambiar de imagen, siempre que el foco esté sobre el input. Dataset # Sketch Code \u0026#39;use strict\u0026#39;; let img; let pixelatorShader; let resolution; let mode; let input; let imgcode; let dataset = []; let video_on; function preload() { img = loadImage(`/VisualComputing/docs/shaders/resources/dataset/${int(random(1, 31))}.jpg`); for (let i = 1; i \u0026lt;= 30; i++) { dataset.push(loadImage(`/VisualComputing/docs/shaders/resources/dataset/${i}.jpg`)); } pixelatorShader = readShader(\u0026#39;/VisualComputing/docs/shaders/fragments/pixelator.frag\u0026#39;, { matrices: Tree.NONE, varyings: Tree.texcoords2 }); } function setup() { createCanvas(600, 600, WEBGL); textureMode(NORMAL); noStroke(); shader(pixelatorShader); resolution = createSlider(1, 150, 30, 1); resolution.position(100, 10); resolution.style(\u0026#39;width\u0026#39;, \u0026#39;150px\u0026#39;); resolution.input(() =\u0026gt; pixelatorShader.setUniform(\u0026#39;resolution\u0026#39;, resolution.value())); pixelatorShader.setUniform(\u0026#39;resolution\u0026#39;, resolution.value()); mode = createSelect(); mode.position(10, 10); mode.option(\u0026#39;original\u0026#39;); mode.option(\u0026#39;pixelator\u0026#39;); mode.selected(\u0026#39;pixelator\u0026#39;); mode.changed(() =\u0026gt; { if (mode.value() == \u0026#39;original\u0026#39;) resolution.hide(); else resolution.show(); pixelatorShader.setUniform(\u0026#39;original\u0026#39;, mode.value() === \u0026#39;original\u0026#39;); }); input = createFileInput(handleFile); imgcode = createInput(\u0026#39;\u0026#39;, \u0026#39;number\u0026#39;); video_on = createCheckbox(\u0026#39;default video\u0026#39;, false); video_on.changed(() =\u0026gt; { if (video_on.checked()) { img = createVideo([\u0026#39;/VisualComputing/docs/shaders/resources/video2.mp4\u0026#39;]); img.hide(); img.loop(); } else { img = loadImage(`/VisualComputing/docs/shaders/resources/dataset/${int(random(1, 31))}.jpg`); img.hide(); img.pause(); } photomosaicShader.setUniform(\u0026#39;source\u0026#39;, img); }) } function draw() { if (imgcode.value() != \u0026#39;\u0026#39;) { img = dataset[(parseInt(imgcode.value()) - 1) % dataset.length]; } if (img != null) { image(img, 0, 0, 600, 600); pixelatorShader.setUniform(\u0026#39;source\u0026#39;, img); beginShape(); vertex(-1, -1, 0, 0, 1); vertex(1, -1, 0, 1, 1); vertex(1, 1, 0, 1, 0); vertex(-1, 1, 0, 0, 0); endShape(); } } function handleFile(file) { if (file.type === \u0026#39;image\u0026#39;) { img = createImg(file.data, \u0026#39;\u0026#39;); img.hide(); } else if (file.type === \u0026#39;video\u0026#39;) { img = createVideo([file.data]); img.hide(); img.loop(); imgcode.value(\u0026#39;\u0026#39;) // to avoid getting dataset image instead } } Pixelator Shader Code precision mediump float; // source (image or video) is sent by the sketch uniform sampler2D source; // displays original uniform bool original; // target horizontal \u0026amp; vertical resolution uniform float resolution; // interpolated texcoord (same name and type as in vertex shader) // defined as a (normalized) vec2 in [0..1] varying vec2 texcoords2; void main() { if (original) { gl_FragColor = texture2D(source, texcoords2); } else { // define stepCoord to sample the texture source as a 3-step process: // i. define stepCoord as a texcoords2 remapping in [0.0, resolution] ∈ R vec2 stepCoord = texcoords2 * resolution; // ii. remap stepCoord in [0.0, resolution] ∈ Z // see: https://thebookofshaders.com/glossary/?search=floor stepCoord = floor(stepCoord); // iii. remap stepCoord in [0.0, 1.0] ∈ R stepCoord = stepCoord / vec2(resolution); // source texel gl_FragColor = texture2D(source, stepCoord); // ✨ source texels may be used to compute image palette lookup keys, // such as in video \u0026amp; photographic mosaics or ascii art visualizations. } } Average Color (No Spatial Coherence) # A continuación se muestra la implementación hecha en software (no hardware) de la pixelación que no usa coherencia espacial (elegir arbitrariamente uno de los pixeles de una sección para pintar el pixel de baja resolución de dicha sección), sino que hace un promedio de los colores de los pixeles de toda la sección y así pinta el pixel de baja resolución.\nEl usuario debe cargar la imagen manualmente (puede descargar la versión original haciendo click derecho sobre la imagen en la aplicación que usa coherencia espacial y luego subirla aquí). El usuario debe mover el slider si es necesario para que tengan la misma resolución ambas implementaciones para poder comparar.\nControles # Botón Choose File: para cargar una imagen o video Slider: define la resolución (por defecto 30, es decir 30 pixeles de baja resolución por cada lado de la cuadrícula). El mínimo valor es 1 y el máximo 150. Una resolución mayor, implica más pixeles, y por tanto, de menor tamaño cada vez. El tamaño de la cuadrícula es de 600px x 600px por lo que una resolución de 150 implica pixeles de baja resolución de dimensiones 4px x 4px. Sketch Code let mid = 10; let w = 20; // pixel width and height: split is in groups of 256 pixels. let input; let img; let width; let height; let resolution; function setup() { input = createFileInput(handleFile); resolution = createSlider(1, 150, 30, 1); resolution.position(100, 10); resolution.style(\u0026#39;width\u0026#39;, \u0026#39;150px\u0026#39;); resolution.input(() =\u0026gt; { w = Math.floor(600 / resolution.value()); mid = Math.floor(w / 2); }); } function draw() { if (img != null \u0026amp;\u0026amp; img.width \u0026gt; 0) { width = 600; height = 600; input.position(2 * width, 0); createCanvas(2 * width, height); image(img, width, 0, 600, 600); fill(100); noStroke(); for (let i = 0; i \u0026lt; width; i += w) { for (let j = 0; j \u0026lt; height; j += w) { square(i, j, w); } } let COLORS = {} for (let i = 0; i \u0026lt; width; i++) { let i_ = i + width; for (let j = 0; j \u0026lt; height; j++) { let color = get(i_, j); let key = `${Math.floor(i / w)}-${Math.floor(j / w)}`; if (COLORS[key] == null) COLORS[key] = []; COLORS[key].push(color); } } for (const key in COLORS) { let colors = COLORS[key] let R = 0; let G = 0; let B = 0; colors.forEach((c) =\u0026gt; { R += c[0]; G += c[1]; B += c[2]; }) COLORS[key] = [Math.floor(R / w**2), Math.floor(G / w**2), Math.floor(B / w**2)] } for (const key in COLORS) { fill(COLORS[key]) let x = parseInt(key.split(\u0026#39;-\u0026#39;)[0]) let y = parseInt(key.split(\u0026#39;-\u0026#39;)[1]) square(x*w, y*w, w); } } } function handleFile(file) { if (file.type === \u0026#39;image\u0026#39;) { img = createImg(file.data, \u0026#39;\u0026#39;); img.hide(); } else { img = null; } } "},{"id":10,"href":"/VisualComputing/docs/shaders/photomosaic/","title":"Photomosaic","section":"Shaders","content":" Exercise # Implement a mosaic (or/and ascii art) visual application.\nImages Photomosaic # En esta aplicación, se usa el mismo mecanismo de pixelación visto en Spatial Coherence con la diferencia de que cada pixel de baja resolución es mapeado a una imagen. El shader recibe una imagen que contiene todas las imágenees del dataset que compondrán el mosaico. Estas imágenes están ordenadas siguiendo alguna métrica, que en nuestro caso es el luma. El shader calcula el color del pixel de baja resolución para texel. A ese color le calcula el luma. Este luma obtenido le indica a la función texture2D, qué tanto se debe desplazar horizontalmente hacia la derecha desde el extremo izquierdo para obtener así la coordenada x de la imagen que se quiere dibujar en esa sección (es decir, dónde empieza la imagen en el buffer recibido).\nControles # Botón Choose File: para cargar una imagen o video Checkbox Default Video: marcar para usar el video por defecto, desmarcar para usar la imagen por defecto Slider: define la resolución (por defecto 30, es decir 30 pixeles de baja resolución que en este caso serán imágenes del mosaico por cada lado de la cuadrícula). El mínimo valor es 1 y el máximo 150. Una resolución mayor, implica más pixeles, y por tanto, de menor tamaño cada vez. El tamaño de la cuadrícula es de 600px x 600px por lo que una resolución de 150 implica pixeles de baja resolución de dimensiones 4px x 4px. Select: para decidir si ver la imagen pixelada (keys), la original o el mosaico. Input: ingrese un número entre 1 y 30 para escoger una imagen del dataset. El dataset se muestra en orden abajo de esta aplicación. Observe por ejemplo que panda rojo le corresponde el número 7. Una vez ingresado un número puede usar las flechas de su teclado para cambiar de imagen, siempre que el foco esté sobre el input. Dataset # Sketch Code \u0026#39;use strict\u0026#39;; let img; let photomosaicShader; let resolution; let mode; let input; let dataset = []; let palette; let pg; let imgcode; let video_on; const SAMPLE_RES = 30; function preload() { img = loadImage(`/VisualComputing/docs/shaders/resources/dataset/${int(random(1, 31))}.jpg`); for (let i = 1; i \u0026lt;= 30; i++) { dataset.push(loadImage(`/VisualComputing/docs/shaders/resources/dataset/${i}.jpg`)); } photomosaicShader = readShader(\u0026#39;/VisualComputing/docs/shaders/fragments/photomosaic.frag\u0026#39;, { matrices: Tree.NONE, varyings: Tree.texcoords2 }); } function setup() { createCanvas(600, 600, WEBGL); textureMode(NORMAL); noStroke(); shader(photomosaicShader); resolution = createSlider(1, 150, 100, 1); resolution.position(100, 10); resolution.style(\u0026#39;width\u0026#39;, \u0026#39;150px\u0026#39;); resolution.input(() =\u0026gt; photomosaicShader.setUniform(\u0026#39;resolution\u0026#39;, resolution.value())); photomosaicShader.setUniform(\u0026#39;resolution\u0026#39;, resolution.value()); mode = createSelect(); mode.position(10, 10); mode.option(\u0026#39;original\u0026#39;); mode.option(\u0026#39;keys\u0026#39;); mode.option(\u0026#39;photomosaic\u0026#39;); mode.selected(\u0026#39;photomosaic\u0026#39;); mode.changed(() =\u0026gt; { if (mode.value() == \u0026#39;original\u0026#39;) resolution.hide(); else resolution.show(); photomosaicShader.setUniform(\u0026#39;original\u0026#39;, mode.value() === \u0026#39;original\u0026#39;); photomosaicShader.setUniform(\u0026#39;keys\u0026#39;, mode.value() === \u0026#39;keys\u0026#39;); }); input = createFileInput(handleFile); imgcode = createInput(\u0026#39;\u0026#39;, \u0026#39;number\u0026#39;); palette = createQuadrille(dataset); console.log(palette.height) pg = createGraphics(SAMPLE_RES * palette.width, SAMPLE_RES); photomosaicShader.setUniform(\u0026#39;n\u0026#39;, palette.width); sample(); video_on = createCheckbox(\u0026#39;default video\u0026#39;, false); video_on.changed(() =\u0026gt; { if (video_on.checked()) { img = createVideo([\u0026#39;/VisualComputing/docs/shaders/resources/video2.mp4\u0026#39;]); img.hide(); img.loop(); } else { img = loadImage(`/VisualComputing/docs/shaders/resources/dataset/${int(random(1, 31))}.jpg`); img.hide(); img.pause(); } photomosaicShader.setUniform(\u0026#39;source\u0026#39;, img); }) } function draw() { if (imgcode.value() != \u0026#39;\u0026#39;) { img = dataset[(parseInt(imgcode.value()) - 1) % dataset.length]; } if (img != null) { image(img, 0, 0, 600, 600); photomosaicShader.setUniform(\u0026#39;source\u0026#39;, img); beginShape(); vertex(-1, -1, 0, 0, 1); vertex(1, -1, 0, 1, 1); vertex(1, 1, 0, 1, 0); vertex(-1, 1, 0, 0, 0); endShape(); } } function sample() { if (pg.width !== SAMPLE_RES * palette.width) { pg = createGraphics(SAMPLE_RES * palette.width, SAMPLE_RES); photomosaicShader.setUniform(\u0026#39;n\u0026#39;, palette.width); } palette.sort({ ascending: true, cellLength: SAMPLE_RES }); drawQuadrille(palette, { graphics: pg, cellLength: 30, outlineWeight: 0 }); photomosaicShader.setUniform(\u0026#39;palette\u0026#39;, pg); } function handleFile(file) { if (file.type === \u0026#39;image\u0026#39;) { img = createImg(file.data, \u0026#39;\u0026#39;); img.hide(); } else if (file.type === \u0026#39;video\u0026#39;) { img = createVideo([file.data]); img.hide(); img.loop(); imgcode.value(\u0026#39;\u0026#39;) // to avoid getting dataset image instead } } Photomosaic Shader Code precision mediump float; uniform sampler2D palette; // source (image or video) is sent by the sketch uniform sampler2D source; uniform bool keys; // displays original uniform bool original; // target horizontal \u0026amp; vertical resolution uniform float resolution; uniform float n; // interpolated texcoord (same name and type as in vertex shader) // defined as a (normalized) vec2 in [0..1] varying vec2 texcoords2; float luma(vec3 texel) { return 0.299 * texel.r + 0.587 * texel.g + 0.114 * texel.b; // min 0, max 255 } void main() { if (original) { gl_FragColor = texture2D(source, texcoords2); } else { // i. define coord as a texcoords2 remapping in [0.0, resolution] ∈ R vec2 coord = texcoords2 * resolution; // ii. remap stepCoord in [0.0, resolution] ∈ Z vec2 stepCoord = floor(coord); vec2 symbolCoord = coord - stepCoord; // iii. remap stepCoord in [0.0, 1.0] ∈ R stepCoord = stepCoord / vec2(resolution); // normalized step coord // source texel vec4 key = texture2D(source, stepCoord); // texel will be the key to look up // we calculate key color luma float kluma = luma(key.rgb); // palette is an image containing the 30 images but with 1.0 x 1.0 dimensions. // each key will get an image from the palette: we have the symbol coord (x, y). // images are ordered horizontally, so we take x, which indicates the starting coordinate of our key, and divide it by n because we have n images, // with this we can start counting from the left-most image to the right // to this quotient, we add kluma, which is a value between 0 a 1. It will ensure we are going to use the correct image texel. // y coordinate need no special treatment. // for each texel, we need to paint the correct portion of the image that will represent vec4 paletteTexel = texture2D(palette, vec2(symbolCoord.x / n + kluma, symbolCoord.y)); gl_FragColor = keys ? key : paletteTexel; } } ASCII Art (Software Only, No Shaders) # Para el de imágenes, se disminuyó el tamaño de los caracteres a 4pt y su interlineado para poder visualizar la imagen en un espacio más pequeño.\nSketch Code const density = \u0026#39;qwerty12345\u0026#39;; let video; let asciiDiv; function setup() { noCanvas(); video = createVideo( [\u0026#39;/VisualComputing/docs/shaders/resources/bicho.mp4\u0026#39;], vidLoad ); video.size(100, 100); asciiDiv = createDiv(); } function vidLoad() { video.loop(); video.volume(0); } function draw(){ video.loadPixels(); let asciiImage = \u0026#39;\u0026#39;; for(let j = 0; j \u0026lt; video.height; j++){ for(let i = 0; i \u0026lt; video.width; i++){ const pixelIndex = (i + j * video.width) * 4; const r = video.pixels[pixelIndex + 0]; const g = video.pixels[pixelIndex + 1]; const b = video.pixels[pixelIndex + 2]; const avg = (r + g + b) / 3; const len = density.length; const charIndex = floor(map(avg, 0, 255, len, 0)); const c = density.charAt(charIndex); if (c == \u0026#39;\u0026#39;) asciiImage += \u0026#39;\u0026amp;nbsp;\u0026#39; else asciiImage += c; } asciiImage += \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;; } asciiDiv.html(asciiImage); } Sketch Code const density = \u0026#39;qwerty12345\u0026#39;; let photo; function preload(){ photo = loadImage(\u0026#34;/VisualComputing/docs/shaders/resources/photo.jpg\u0026#34;) } function setup() { noCanvas(); background(0); image(photo,0,0,width,height); let w = width/photo.width; let h = height/photo.height; photo.loadPixels(); for(let j = 0; j \u0026lt; photo.height; j++){ let row = \u0026#39;\u0026#39;; for(let i = 0; i \u0026lt; photo.width; i++){ const pixelIndex = (i + j * photo.width) * 4; const r = photo.pixels[pixelIndex + 0]; const g = photo.pixels[pixelIndex + 1]; const b = photo.pixels[pixelIndex + 2]; const avg = (r + g + b) / 3; const len = density.length; const charIndex = floor(map(avg, 0, 255, len, 0)); const c = density.charAt(charIndex); if (c == \u0026#39;\u0026#39;) row += \u0026#39;\u0026amp;nbsp;\u0026#39; else row += c; } createDiv(row); } } "},{"id":11,"href":"/VisualComputing/docs/shaders/lighting/","title":"Lighting","section":"Shaders","content":" Lighting # La iluminación en gráficos por computadora se refiere a la colocación de luces en una escena para lograr algún efecto deseado. Los paquetes de síntesis de imágenes y animación contienen diferentes tipos de luces que se pueden colocar en diferentes lugares y modificar cambiando los parámetros. Con demasiada frecuencia, las personas que crean imágenes o animaciones ignoran o ponen poco énfasis en la iluminación. [2]\nEn gráficos por computadora, el efecto general de una fuente de luz sobre un objeto está determinado por la combinación de las interacciones del objeto con él, generalmente descritas por al menos tres componentes principales. Los tres componentes principales de iluminación (y los tipos de interacción subsiguientes) son difusos, ambientales y especulares. [3]\nLuz ambiental # Una luz ambiental proyecta suaves rayos de luz en todas las direcciones. No tienen una direccionalidad específica, por lo que no proyectan sombras y simula más una luz secundaria que proviene de todos los ángulos diferentes del objeto. La iluminación ambiental es una buena alternativa para rellenar áreas en un render que no tiene suficiente iluminación. [2]\nEjercicio # Implemente una escena que haga uso de la siguiente ecuación de ilumincación donde ambient4 es el color de la luz ambiental. Código let easycam; let myShader; let models; let ambient; let ambientSlider; let modelsSlider; let colorPicker; function preload() { myShader = readShader(\u0026#34;ambient.frag\u0026#34;, {varyings: Tree.NONE,}); } function setup() { createCanvas(500, 500, WEBGL); noLights(); colorMode(RGB, 1); setAttributes(\u0026#39;ambient\u0026#39;, true); let state = { distance: 250, center: [0, 0, 0], rotation: [-0.250, -0.150, -0.500, 0.700], }; easycam = new Dw.EasyCam(this._renderer); easycam.state_reset = state; easycam.setState(state, 2000); document.oncontextmenu = function () { return false; } let trange = 100; models = []; for (let i = 0; i \u0026lt; 100; i++) { models.push({ position: createVector( (random()*2-1) * trange, (random()*2-1) * trange, (random()*2-1) * trange ), size: random() * 30 , color: color(random(), random(), random()), }); } itemsPlane = createSlider(1, models.length, int(models.length / 3), 1); itemsPlane.position(10, 30); ambientSlider = createSlider(0, 1, 0.5, 0.05); ambientSlider.position(350, 30); ambientSlider.input(() =\u0026gt; { myShader.setUniform(\u0026#34;ambient\u0026#34;, ambientSlider.value());}); colorPicker = createColorPicker(\u0026#34;#FFFFFF\u0026#34;); colorPicker.position(50,80) colorPicker.input(() =\u0026gt; { let color = colorPicker.color(); myShader.setUniform(\u0026#34;lightColor\u0026#34;, [red(color) / 255,green(color) / 255,blue(color) / 255,1, ]); }); shader(myShader); myShader.setUniform(\u0026#34;ambient\u0026#34;, ambientSlider.value()); myShader.setUniform(\u0026#34;lightColor\u0026#34;, [1, 1, 1, 1]); } function draw() { background(0); resetShader(); push(); stroke(\u0026#34;blue\u0026#34;); axes(); grid(); pop(); shader(myShader); for (let i = 0; i \u0026lt; itemsPlane.value(); i++) { push(); noStroke(); fill(models[i].color); translate(models[i].position); let radius = models[i].size / 2; i % 3 === 0 ? box(radius) : i % 3 === 1 ? sphere(radius) : torus(radius, radius / 4); pop(); } } Shader precision mediump float; // emitted by p5 color-group commands // https://p5js.org/reference/#group-Color uniform vec4 uMaterialColor; uniform vec4 lightColor; uniform float ambient; void main() { vec4 ambient4 = lightColor * ambient; gl_FragColor = ambient4 * uMaterialColor; } Reflexion especular # Se refiere a los reflejos de los objetos reflectantes, como diamantes, bolas de billar y ojos. Los reflejos especulares a menudo aparecen como puntos brillantes en una superficie, en un punto donde la fuente de luz incide directamente. Ambient, Diffuse y Specular se denominan los tres componentes de una fuente de luz. [3]\nUna reflexión especular es visible solo donde la superficie normal está orientada precisamente a la mitad entre la dirección de la luz entrante y la dirección del espectador; esto se llama la dirección del medio ángulo porque biseca (divide en dos) el ángulo entre la luz entrante y el espectador. Por lo tanto, una superficie reflectora especular mostraría un punto culminante especular como la imagen reflejada perfectamente nítida de una fuente de luz. Sin embargo, muchos objetos brillantes muestran reflejos especulares borrosos.[4]\nEjercicio # Implementar una escena de sombreado de dibujos animados o Toon Shader apartir de la reflexion especular\nCódigo let toonShader; let myShader; let models; let ambient; let ambientSlider; let modelsSlider; let colorPicker; function preload() { toonShader = loadShader(\u0026#39;vert.frag\u0026#39;, \u0026#39;frag.frag\u0026#39;); } function setup() { createCanvas(500, 500, WEBGL); noLights(); colorMode(RGB, 1); setAttributes(\u0026#39;ambient\u0026#39;, true); let state = { distance: 250, center: [0, 0, 0], rotation: [-0.250, -0.150, -0.500, 0.700], }; easycam = new Dw.EasyCam(this._renderer); easycam.state_reset = state; easycam.setState(state, 2000); document.oncontextmenu = function () { return false; } let trange = 90; models = []; for (let i = 0; i \u0026lt; 100; i++) { models.push({ position: createVector( (random()*2-1) * trange, (random()*2-1) * trange, (random()*2-1) * trange ), size: random() * 30 , color: color(random(), random(), random()), }); } itemsPlane = createSlider(1, models.length, int(models.length / 3), 1); itemsPlane.position(10, 30); ambientSlider = createSlider(0, 1, 0.5, 0.05); ambientSlider.position(350, 30); ambientSlider.input(() =\u0026gt; { toonShader.setUniform(\u0026#34;fraction\u0026#34;, ambientSlider.value());}); colorPicker = createColorPicker(\u0026#34;#FFFFFF\u0026#34;); colorPicker.position(50,80) colorPicker.input(() =\u0026gt; { let color = colorPicker.color(); toonShader.setUniform(\u0026#34;lightColor\u0026#34;, [red(color) / 255,green(color) / 255,blue(color) / 255,1, ]); }); shader(toonShader); toonShader.setUniform(\u0026#39;fraction\u0026#39;, 1.0); toonShader.setUniform(\u0026#34;ambient\u0026#34;, ambientSlider.value()); toonShader.setUniform(\u0026#34;lightColor\u0026#34;, [1, 1, 1, 1]); } function draw() { background(0); resetShader(); push(); stroke(\u0026#34;blue\u0026#34;); axes(); grid(); pop(); shader(toonShader); push(); let dirY = (mouseY / height - 0.5) * 2; let dirX = -(mouseX / width - 0.5) * 2; directionalLight(255, 255, 204, dirX, -dirY, -1); for (let i = 0; i \u0026lt; itemsPlane.value(); i++) { push(); noStroke(); fill(models[i].color); translate(models[i].position); let radius = models[i].size / 2; i % 3 === 0 ? box(radius) : i % 3 === 1 ? sphere(radius) : torus(radius, radius / 4); pop(); } pop(); } Shader-frag attribute vec3 aPosition; attribute vec3 aNormal; attribute vec2 aTexCoord; attribute vec4 aVertexColor; uniform mat4 uModelViewMatrix; uniform mat4 uProjectionMatrix; uniform mat3 uNormalMatrix; uniform int uDirectionalLightCount; uniform vec3 uLightingDirection; uniform vec3 uDirectionalColor; uniform vec4 uMaterialColor; varying vec4 vertColor; varying vec3 vertLightDir; varying vec3 vertNormal; varying vec2 vertTexCoord; void main() { vec4 positionVec4 = vec4(aPosition, 1.0); gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4; vertNormal = normalize(uNormalMatrix * aNormal); vertLightDir = -uLightingDirection; vertColor = uMaterialColor; vertTexCoord = aTexCoord; } Shader-vert #ifdef GL_ES precision mediump float; precision mediump int; #endif uniform float fraction; uniform vec4 lightColor; uniform float ambient; varying vec4 vertColor; varying vec3 vertNormal; varying vec3 vertLightDir; varying highp vec2 vertTexCoord; void main() { float intensity; vec4 color; intensity = max(0.0, dot(vertLightDir, vertNormal)); if (intensity \u0026gt; pow(0.95, fraction)) { color = vec4(vec3(1.0), 1.0); } else if (intensity \u0026gt; pow(0.5, fraction)) { color = vec4(vec3(0.6), 1.0); } else if (intensity \u0026gt; pow(0.25, fraction)) { color = vec4(vec3(0.4), 1.0); } else { color = vec4(vec3(0.2), 1.0); } gl_FragColor = color * vertColor * lightColor; } Reflexión difusa # La iluminación difusa (o reflexión difusa) es la iluminación directa de un objeto por una cantidad uniforme de luz que interactúa con una superficie que dispersa la luz.Después de que la luz incide en un objeto, se refleja en función de las propiedades de la superficie del objeto, así como del ángulo de la luz entrante. Esta interacción es el principal contribuyente al brillo del objeto y constituye la base de su color. [2]\nEjercicio # Implemente una escena de reflexión difusa: Código let easycam; let models; let itemsPlane; let myShader; let ambient; let ambientSlider; let focos; let selectPos; function preload() { myShader = readShader(\u0026#39;ambient.frag\u0026#39;, { varyings: Tree.normal3 | Tree.position4 }); } function setup() { createCanvas(500, 500, WEBGL); noLights(); colorMode(RGB, 1); setAttributes(\u0026#39;ambient\u0026#39;, true); let state = { distance: 250, center: [0, 0, 0], rotation: [-0.250, -0.150, -0.500, 0.700], }; easycam = new Dw.EasyCam(this._renderer); easycam.state_reset = state; easycam.setState(state, 2000); document.oncontextmenu = function () { return false; } let trange = 100; models = []; for (let i = 0; i \u0026lt; 100; i++) { models.push({ position: createVector( (random()*2-1) * trange, (random()*2-1) * trange, (random()*2-1) * trange ), size: random() * 30 , color: color(random(), random(), random()), }); } focos = {}; itemsPlane = createSlider(1, models.length, int(models.length / 3), 1); itemsPlane.position(10, 30); ambientSlider = createSlider(0, 1, 0.2, 0.05); ambientSlider.position(350, 30); ambientSlider.input(() =\u0026gt; { myShader.setUniform(\u0026#39;ambient\u0026#39;, ambientSlider.value()) }); selectPos = createSelect(); selectPos.position(40, 80); selectPos.option(\u0026#39;Centro\u0026#39;); selectPos.option(\u0026#39;Izquierda\u0026#39;); selectPos.option(\u0026#39;Derecha\u0026#39;); selectPos.selected(\u0026#39;Centro\u0026#39;); colorPicker = createColorPicker(\u0026#34;#FFFFFF\u0026#34;); colorPicker.position(400,80) colorPicker.input(() =\u0026gt; { let color = colorPicker.color(); myShader.setUniform(\u0026#34;lightColor\u0026#34;, [ red(color) / 255, green(color) / 255, blue(color) / 255, 1, ]); }); shader(myShader); myShader.setUniform(\u0026#39;ambient\u0026#39;, ambientSlider.value()); myShader.setUniform(\u0026#34;lightColor\u0026#34;, [1, 1, 1, 1]); } function draw() { background(0); let point = updatePointLight(); resetShader(); push(); stroke(\u0026#39;blue\u0026#39;); axes(); grid(); pop(); push(); translate(point.position); noStroke(); fill(\u0026#39;white\u0026#39;); sphere(3); pop(); shader(myShader); myShader.setUniform(\u0026#39;uLightPosition\u0026#39;, treeLocation(point.position, { from: Tree.WORLD, to: Tree.EYE }).array()); for (let i = 0; i \u0026lt; itemsPlane.value(); i++) { push(); noStroke(); fill(models[i].color); translate(models[i].position); let radius = models[i].size / 2; i % 3 === 0 ? box(radius * 2) : i % 3 === 1 ? sphere(radius) : torus(radius, radius / 4); pop(); } } function updatePointLight() { let mov = frameCount * 0.03; let rad = 30; let px = cos(mov) * rad; let py = sin(mov) * rad; let r = (sin(mov) * 1 + 0.5); let g = (sin(mov * 0.5 + PI ) * 0.5 + 0.5); let b = (sin(frameCount * 0.05) * 0.5 + 0.5); let pz = sin(frameCount * 0.05); return { position: selectPos.value() === \u0026#39;Centro\u0026#39; ? createVector(px, py, 0) : selectPos.value() === \u0026#39;Izquierda\u0026#39; ? createVector(50, 50, pz * 70) : createVector(-50, -50, -pz * 70), color: selectPos.value() === \u0026#39;Centro\u0026#39; ? color(1 - r, r / 2, r) : selectPos.value() === \u0026#39;Izquierda\u0026#39; ? color(r, 1, g) : color(1, r, g) }; } Shader precision mediump float; uniform float ambient; uniform vec4 uMaterialColor; uniform vec4 lightColor; // uLightPosition is given in eye space uniform vec3 uLightPosition; // both, normal3 and position4 are given in eye space as well varying vec3 normal3; varying vec4 position4; void main() { vec3 direction3 = uLightPosition - position4.xyz; // solve the diffuse light equation discarding negative values // see: https://thebookofshaders.com/glossary/?search=max // see: https://thebookofshaders.com/glossary/?search=dot float diffuse = max(0.0, dot(normalize(direction3), normalize(normal3))); gl_FragColor = (ambient + diffuse) * uMaterialColor * lightColor; } Ejercicio # Implemente una escena combinando luces de ambiente, difusa y especular. Considerar varias fuentes puntuales de luz, con factores de atenuación [5] y exponentes de Phong[6].\nCódigo let easycam; let models; let itemsPlane; let myShader; let ambient; let ambientSlider; let selectPos; let phongExpSlider; let attenuationRate; let lightCount; let lights; let colorPicker; let colors; let lightsColors; function preload() { myShader = readShader(\u0026#39;/VisualComputing/sketches/Lighting_4/ambient.frag\u0026#39;, { varyings: Tree.normal3 | Tree.position4 }); } function setup() { createCanvas(500, 500, WEBGL); noLights(); colorMode(RGB, 1); setAttributes(\u0026#39;ambient\u0026#39;, true); let state = { distance: 250, center: [0, 0, 0], rotation: [-0.250, -0.150, -0.500, 0.700], }; easycam = new Dw.EasyCam(this._renderer); easycam.state_reset = state; easycam.setState(state, 2000); document.oncontextmenu = function () { return false; } let trange = 100; models = []; for (let i = 0; i \u0026lt; 100; i++) { models.push({ position: createVector( (random()*2-1) * trange, (random()*2-1) * trange, (random()*2-1) * trange ), size: random() * 30 , color: color(random(), random(), random()), }); } itemsPlane = createSlider(1, models.length, int(models.length / 3), 1); itemsPlane.position(10, 30); ambientSlider = createSlider(0, 1, 0.2, 0.05); ambientSlider.position(350, 30); ambientSlider.input(() =\u0026gt; { myShader.setUniform(\u0026#39;ambient\u0026#39;, ambientSlider.value()) }); selectPos = createSelect(); selectPos.position(20, 80); selectPos.option(1); selectPos.option(2); selectPos.option(3); selectPos.selected(1); selectPos.input(() =\u0026gt; { let count = selectPos.value() === 1 ? 1 : selectPos.value() === 2 ? 2 : 3; myShader.setUniform(\u0026#39;lightCount\u0026#39;, count) }); colors = []; lightsColors = []; for (let i = 0; i \u0026lt; 3; i++) { colors[i] = createColorPicker(\u0026#34;#FFFFFF\u0026#34;); colors[i].position(20,120+(i*45)) colors[i].input(() =\u0026gt; { let color = colors[i].color(); lightsColors[i*4+0] = red(color) / 255; lightsColors[i*4+1] = green(color) / 255; lightsColors[i*4+2] = blue(color) / 255; lightsColors[i*4+3] = 1; myShader.setUniform(\u0026#34;lightsColors\u0026#34;, lightsColors); }); } colorPicker = createColorPicker(\u0026#34;#FFFFFF\u0026#34;); colorPicker.position(400,80) colorPicker.input(() =\u0026gt; { let color = colorPicker.color(); myShader.setUniform(\u0026#34;ambientColor\u0026#34;, [ red(color) / 255, green(color) / 255, blue(color) / 255, 1, ]); }); phongExpSlider = createSlider(2, 1250, 1, 1); phongExpSlider.position(350, 470); phongExpSlider.input(() =\u0026gt; { myShader.setUniform(\u0026#39;phongExp\u0026#39;, phongExpSlider.value()) }); attenuationRate = createSlider(0, 0.1, 0.03, 0.001); attenuationRate.position(10, 470); attenuationRate.input(() =\u0026gt; { myShader.setUniform(\u0026#39;attenuationRate\u0026#39;, attenuationRate.value()) }); lights = []; shader(myShader); myShader.setUniform(\u0026#39;ambient\u0026#39;, ambientSlider.value()); myShader.setUniform(\u0026#34;ambientColor\u0026#34;, [1, 1, 1, 1]); myShader.setUniform(\u0026#39;phongExp\u0026#39;, phongExpSlider.value()); myShader.setUniform(\u0026#39;attenuationRate\u0026#39;, attenuationRate.value()); myShader.setUniform(\u0026#39;lightCount\u0026#39;, 1); myShader.setUniform(\u0026#39;lightsColors\u0026#39;, [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]); } function draw() { background(0); let point = updatePointLight(); lightsColors = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; resetShader(); push(); stroke(\u0026#39;blue\u0026#39;); axes(); grid(); pop(); for (let i = 0; i \u0026lt; selectPos.value(); i++) { let color = colors[i].color(); lightsColors[i*4+0] = red(color) / 255; lightsColors[i*4+1] = green(color) / 255; lightsColors[i*4+2] = blue(color) / 255; lightsColors[i*4+3] = 1; push(); translate(point[i].position); noStroke(); fill(colors[i].color()); sphere(3); pop(); lights[i] = treeLocation(point[i].position, { from: Tree.WORLD, to: Tree.EYE }).array(); } shader(myShader); myShader.setUniform(\u0026#39;uLightPosition\u0026#39;, lights.flat()); myShader.setUniform(\u0026#34;lightsColors\u0026#34;, lightsColors); for (let i = 0; i \u0026lt; itemsPlane.value(); i++) { push(); noStroke(); fill(models[i].color); translate(models[i].position); let radius = models[i].size / 2; i % 3 === 0 ? box(radius * 2) : i % 3 === 1 ? sphere(radius) : torus(radius, radius / 4); pop(); } } function updatePointLight() { let mov = frameCount * 0.03; let rad = 30; let px = cos(mov) * rad; let py = sin(mov) * rad; let r = (sin(mov) * 1 + 0.5); let g = (sin(mov * 0.5 + PI ) * 0.5 + 0.5); let b = (sin(frameCount * 0.05) * 0.5 + 0.5); let pz = sin(frameCount * 0.05); return [{ position: createVector(px, py, 0), color: color(1 - r, r / 2, r) }, { position: createVector(50, 50, pz * 70), color: color(r, 1, g) }, { position: createVector(-50, -50, -pz * 70), color: color(1, r, g) }]; } Shader precision mediump float; uniform float ambient; uniform vec4 uMaterialColor; uniform vec4 ambientColor; uniform float lightsColors[12]; uniform float phongExp; uniform float attenuationRate; // uLightPosition is given in eye space uniform int lightCount; uniform float uLightPosition[12]; // both, normal3 and position4 are given in eye space as well varying vec3 normal3; varying vec4 position4; void main() { vec4 sum = vec4(0.0, 0.0, 0.0, 0.0); for (int i = 0; i \u0026lt; 3; i++) { if (i == lightCount) break; vec3 direction3 = vec3(uLightPosition[i*3], uLightPosition[i*3+1], uLightPosition[i*3+2]) - position4.xyz; float d = length( direction3 ); float attenuation = 1.0 / (1.0 + attenuationRate * d); float diffuse = max(0.0, dot(normalize(direction3), normalize(normal3))); float specular = pow(max(0.0, dot(normalize(reflect(-direction3, normal3)), normalize(-vec3(position4)))), phongExp); vec4 color = vec4(lightsColors[i*4], lightsColors[i*4+1], lightsColors[i*4+2], lightsColors[i*4+3]); sum += attenuation * (diffuse + specular) * color; } gl_FragColor = ((ambient * ambientColor) + sum) * uMaterialColor; } Referencias # \u0026ldquo;ToonShader\u0026rdquo;, 2017 jwdunn1, P5js Editor Web \u0026ldquo;Computer Graphics: Shading and Lighting\u0026rdquo;. cglearn.codelight.eu. Retrieved 2019-10-30. \u0026ldquo;Lighting in 3D Graphics\u0026rdquo;. www.bcchang.com. Retrieved 2019-11-05. \u0026ldquo;Lighting and Shading\u0026rdquo; (PDF) Pollard, Nancy (Spring 2004). \u0026ldquo;Light Attenuation\u0026rdquo;. http://learnwebgl.brown37.net/09_lights/lights_attenuation.html. Retrieved 2022-11-28. \u0026ldquo;Specular highlight\u0026rdquo;. https://en.wikipedia.org/wiki/Specular_highlight#Phong_distribution. Retrieved 2022-11-28. "}]
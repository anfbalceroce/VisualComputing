<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Visual Computing 2022-2</title><link>https://anfbalceroce.github.io/VisualComputing/</link><description>Recent content on Visual Computing 2022-2</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://anfbalceroce.github.io/VisualComputing/index.xml" rel="self" type="application/rss+xml"/><item><title>Coloring</title><link>https://anfbalceroce.github.io/VisualComputing/docs/shaders/coloring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anfbalceroce.github.io/VisualComputing/docs/shaders/coloring/</guid><description>Exercise # Figure it out the js code of the above sketches. Implement other blending modes. Blending Modes # Esta aplicación aplica diferentes modos de blend a una imagen con un color. La imagen y el color son seleccionados por el usuario.
Primero se renderiza la imagen cargada, y se envía como textura al blend shader. Al blend shader se le envía el color seleccionado por el usuario como un arreglo de JavaScript de cuatro posiciones.</description></item><item><title>Ilusiones</title><link>https://anfbalceroce.github.io/VisualComputing/docs/taller-1/ilusiones/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anfbalceroce.github.io/VisualComputing/docs/taller-1/ilusiones/</guid><description>Ilusiones # Introducción # Aquí se presentan cada una de las siguiente ilusiones con sus respectivas explicaciones sobre cómo funcionan, tratando de explicar porque se dan dichos fenómenos al analizar los diferentes componente de cada ilusiòn.
Steping Illusion # En esta ilusion se observan dos rectangulos de color amarillo y azul que se desplazan a lo largo de un patron de barras claras y oscuras. Cuando las condiciones de color y tamaño son adecuadas los rectangulos parecen moverse de manera intermitente, como si fueran pies caminando.</description></item><item><title>Múltiples Cámaras</title><link>https://anfbalceroce.github.io/VisualComputing/docs/taller-2/camaras/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anfbalceroce.github.io/VisualComputing/docs/taller-2/camaras/</guid><description>Múltiples Cámaras # Tecla Acción W,A,S,D Movimiento E Aumentar velocidad Q Disminuir velocidad Introducción - Descripción de la idea # Para este proyecto se tomo como referencia las cámaras de punto fijo de los juegos de Resident Evil clásicos en los que se jugaba con una cámara de punto fijo:
Tanto el punto de vista como el cambio en las transiciones
Se hizo uso de transformaciones en el espacio y de cámaras con quaterniones, los cuaterniones son muy ́utiles en la representación gráfica por ordenador, debido, entre otras cosas, a la posibilidad que ofrecen de representar con ellos rotaciones en el espacio tridimensional a través de los ángulos de Euler evitando el Gimbal Lock-Bloqueo del cardán.</description></item><item><title>Convolución</title><link>https://anfbalceroce.github.io/VisualComputing/docs/taller-1/convolucion/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anfbalceroce.github.io/VisualComputing/docs/taller-1/convolucion/</guid><description>Marco Teorico # Convolución # 1. Identity: La mascara retorna la misma imagen
\[\begin{bmatrix} 0 &amp;amp; 0 &amp;amp; 0\\ 0 &amp;amp; 1 &amp;amp; 0\\ 0 &amp;amp; 0 &amp;amp; 0 \end{bmatrix}\] 2. Sharpen: El núcleo de nitidez enfatiza las diferencias en los valores de píxeles adyacentes, lo que hace que la imagen parezca más vívida.
\[\begin{bmatrix} 0 &amp;amp; -1 &amp;amp; 0\\ -1 &amp;amp; 5 &amp;amp; -1\\ 0 &amp;amp; -1 &amp;amp; 0 \end{bmatrix}\] 3.</description></item><item><title>Ejercicio Opcional</title><link>https://anfbalceroce.github.io/VisualComputing/docs/taller-2/W2_Optional/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anfbalceroce.github.io/VisualComputing/docs/taller-2/W2_Optional/</guid><description>Workshop 02 - Optional Exercises # Exercise # Implement in software any of the visualizations: primitive rasterization, color shading, z-depth, texture-mapping and/or anti-aliasing (requires a bit of research).
Primitive Rasterization + Color Shading # Press any key to switch between triangles
Implementation Details # Declarations # We declare a variable w that will be each pixel width and height. We declare a variable mid as w/2 to facilitate draawing lines from the center of a pixel.</description></item><item><title>Texturing</title><link>https://anfbalceroce.github.io/VisualComputing/docs/shaders/texturing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anfbalceroce.github.io/VisualComputing/docs/shaders/texturing/</guid><description>Exercise # Implement other coloring brightness tools such as HSV value V, HSL lightness L or Component average. Implement texture tinting by mixing color and texel interpolated data. Brightness &amp;amp; Tinting # El ejercicio se compone de dos partes: La primera consiste en la visualización de la iluminación de la imagen y la segunda es la aplicación de tinting sobre la imagen utilizando diferentes blending modes.
La iluminación se implementó con un brightness shader usando las siguientes cuatro métricas: luma, value (HSV), lightness (HSL) e intensidad (HSI).</description></item><item><title>Image Processing</title><link>https://anfbalceroce.github.io/VisualComputing/docs/shaders/ImageProcessing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anfbalceroce.github.io/VisualComputing/docs/shaders/ImageProcessing/</guid><description>Exercise # Implement an image / video processing app supporting different masks, including other kernel sizes different than 3x3, and:
A region-of-interest base tool to selectively apply a given mask.Hint: circular regions around the mouse pointer are handy and quite simple to implement by means of glsl distance. A magnifier tool. Requires a bit of research. For instance, look for it in shadertoy. Integrate luma and other coloring brightness tools.</description></item><item><title>Procedural Texturing</title><link>https://anfbalceroce.github.io/VisualComputing/docs/shaders/ProceduralTexturing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anfbalceroce.github.io/VisualComputing/docs/shaders/ProceduralTexturing/</guid><description>Exercise # Adapt other patterns from the book of shaders (refer also to the shadertoy collection) and map them as textures onto other 3D shapes.
Procedural Texturing # En este ejercicio, se implementaron dos patrones. Uno tomado de The Book of Shaders: Random llamado Mosaic y otro tomado de generative art deco 4 (Shadertoy) y que aplica el concepto de Chromatic aberration.
Por defecto se mostrará este segundo shader sobre un conjunto de conos generados aleatoriamente y que se mueven cíclicamente por el espacio (mod 400) mientras rotan.</description></item><item><title>Non-Euclidean geometry</title><link>https://anfbalceroce.github.io/VisualComputing/docs/shaders/non-euclidean_geometry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anfbalceroce.github.io/VisualComputing/docs/shaders/non-euclidean_geometry/</guid><description>Non-Euclidean geometry # Marco teórico # Ejercicio # Código let edge = 80; let button1, button2, button3; let use = 1; let bedge = 160; let oedge = 100; let oredge = oedge * Math.sqrt(3); let arrow; let arrowTex; let bee; let beeTex; let tiger; let tigerTex; let tree; let treeTex; let penguin; let penguinTex; let fish; let fishTex; let crown; let crowTex; let tower; let towerTex; let texShader; function preload() { // no varyings need to be emitted from the vertex shader texShader = readShader(&amp;#39;/VisualComputing/sketches/Non_Euclid/non_euclidean.</description></item><item><title>Spatial Coherence</title><link>https://anfbalceroce.github.io/VisualComputing/docs/shaders/SpatialCoherence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anfbalceroce.github.io/VisualComputing/docs/shaders/SpatialCoherence/</guid><description>Exercise # Implement your own source dataset and a mechanism to select different images from it. Implement a pixelator in software that doesn’t use spatial coherence and compare the results with those obtained here. Spatial Coherence # En este ejericio se hace una implementación del pixelado de imágenes usando coherencia espacial. El shader pixelator recibe la imagen y la resolución a utilizar. Una resolución de 30 significa que la imagen pixelada tendrá 30 pixeles de baja resolución (grandes) en cada lado.</description></item><item><title>Photomosaic</title><link>https://anfbalceroce.github.io/VisualComputing/docs/shaders/photomosaic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anfbalceroce.github.io/VisualComputing/docs/shaders/photomosaic/</guid><description>Exercise # Implement a mosaic (or/and ascii art) visual application.
Images Photomosaic # En esta aplicación, se usa el mismo mecanismo de pixelación visto en Spatial Coherence con la diferencia de que cada pixel de baja resolución es mapeado a una imagen. El shader recibe una imagen que contiene todas las imágenees del dataset que compondrán el mosaico. Estas imágenes están ordenadas siguiendo alguna métrica, que en nuestro caso es el luma.</description></item><item><title>Lighting</title><link>https://anfbalceroce.github.io/VisualComputing/docs/shaders/lighting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anfbalceroce.github.io/VisualComputing/docs/shaders/lighting/</guid><description>Lighting # La iluminación en gráficos por computadora se refiere a la colocación de luces en una escena para lograr algún efecto deseado. Los paquetes de síntesis de imágenes y animación contienen diferentes tipos de luces que se pueden colocar en diferentes lugares y modificar cambiando los parámetros. Con demasiada frecuencia, las personas que crean imágenes o animaciones ignoran o ponen poco énfasis en la iluminación. [2]
En gráficos por computadora, el efecto general de una fuente de luz sobre un objeto está determinado por la combinación de las interacciones del objeto con él, generalmente descritas por al menos tres componentes principales.</description></item></channel></rss>